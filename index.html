<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Living World - Boids (Wasm)</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>body{margin:0;background:#111827;}input[type=number],input[type=range]{-moz-appearance:textfield;}input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}.scroll-stable{overflow-anchor:none;}</style>
</head>
<body>
<div id="root"></div>
<script type="module">
import init, { WasmWorld } from './pkg/boids.js';

const {useState,useEffect,useRef,useCallback}=React;

// Visual effect classes (rendering only)
class Ripple{
  constructor(x,y,color,maxRadius=40){this.x=x;this.y=y;this.radius=5;this.maxRadius=maxRadius;this.color=color;this.alpha=0.8}
  update(){this.radius+=2;this.alpha-=0.03;return this.alpha>0}
  draw(ctx){ctx.strokeStyle=this.color.replace(')',`,${this.alpha})`).replace('rgb','rgba');ctx.lineWidth=2;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.stroke()}
}

class DangerZone{
  constructor(x,y){this.x=x;this.y=y;this.intensity=1;this.radius=70}
  update(){this.intensity-=0.002;return this.intensity>0}
  draw(ctx){const g=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.radius);g.addColorStop(0,`rgba(255,0,0,${this.intensity*0.1})`);g.addColorStop(1,'rgba(255,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.fill()}
}

class Shelter{
  constructor(x,y){this.x=x;this.y=y;this.radius=50}
  draw(ctx,dayPhase){ctx.fillStyle=`rgba(40,35,30,${0.8+(1-dayPhase)*0.2})`;ctx.beginPath();ctx.arc(this.x,this.y+10,this.radius,Math.PI,0);ctx.fill();ctx.strokeStyle='rgba(100,200,100,0.2)';ctx.setLineDash([5,5]);ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.stroke();ctx.setLineDash([])}
}

class Nest{
  constructor(x,y,species){this.x=x;this.y=y;this.species=species}
  draw(ctx){ctx.fillStyle=`hsla(${this.species===0?30:45},40%,30%,0.6)`;ctx.beginPath();ctx.ellipse(this.x,this.y,20,12,0,0,Math.PI*2);ctx.fill()}
}

class Tree{
  constructor(x,y){this.x=x;this.y=y;this.height=60+Math.random()*40;this.width=40+Math.random()*20}
  draw(ctx,dayPhase){ctx.fillStyle=`rgba(60,40,30,${0.8+dayPhase*0.2})`;ctx.fillRect(this.x-8,this.y-this.height,16,this.height);ctx.fillStyle=`rgba(${30+dayPhase*20},${80+dayPhase*40},${30+dayPhase*20},0.9)`;ctx.beginPath();ctx.ellipse(this.x,this.y-this.height,this.width/2,this.height*0.4,0,0,Math.PI*2);ctx.fill();ctx.fillStyle=`rgba(${20+dayPhase*15},${60+dayPhase*30},${20+dayPhase*15},0.8)`;ctx.beginPath();ctx.ellipse(this.x-10,this.y-this.height+10,this.width*0.3,this.height*0.25,0,0,Math.PI*2);ctx.fill()}
}

class Pond{
  constructor(x,y,w,h){this.x=x;this.y=y;this.width=w;this.height=h;this.fish=[];this.maxFish=8}
  update(){if(this.fish.length<this.maxFish&&Math.random()<0.01)this.fish.push({x:(Math.random()-0.5)*this.width*0.8,y:(Math.random()-0.5)*this.height*0.6,phase:Math.random()*Math.PI*2});for(let f of this.fish){f.x+=Math.sin(f.phase)*0.3;f.phase+=0.02}}
  draw(ctx){const g=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,Math.max(this.width,this.height)/2);g.addColorStop(0,'rgba(30,80,120,0.8)');g.addColorStop(0.7,'rgba(40,100,140,0.7)');g.addColorStop(1,'rgba(50,120,160,0.5)');ctx.fillStyle=g;ctx.beginPath();ctx.ellipse(this.x,this.y,this.width/2,this.height/2,0,0,Math.PI*2);ctx.fill();ctx.fillStyle='rgba(255,150,50,0.7)';for(let f of this.fish){ctx.beginPath();ctx.ellipse(this.x+f.x,this.y+f.y,4,2,Math.sin(f.phase)*0.3,0,Math.PI*2);ctx.fill()}}
}

const mutationInfo={
  giant:{name:'Giant',emoji:'ðŸ¦£',color:'#f97316',type:'neutral',desc:'50% larger, slower'},
  tiny:{name:'Tiny',emoji:'ðŸœ',color:'#a3e635',type:'neutral',desc:'40% smaller, faster'},
  glowing:{name:'Glowing',emoji:'âœ¨',color:'#fbbf24',type:'special',desc:'Emits light'},
  speedy:{name:'Speedy',emoji:'âš¡',color:'#22d3ee',type:'good',desc:'40% faster'},
  tough:{name:'Tough',emoji:'ðŸ›¡ï¸',color:'#64748b',type:'good',desc:'Resists fatigue'},
  longlived:{name:'Long-lived',emoji:'ðŸ•°ï¸',color:'#c084fc',type:'good',desc:'50% longer lifespan'},
  fertile:{name:'Fertile',emoji:'ðŸ¥š',color:'#fb7185',type:'good',desc:'Reproduces faster'},
  camouflage:{name:'Camouflage',emoji:'ðŸƒ',color:'#4ade80',type:'good',desc:'Harder to catch'},
  aggressive:{name:'Aggressive',emoji:'ðŸ˜¤',color:'#ef4444',type:'neutral',desc:'Attacks others'},
  magnetic:{name:'Magnetic',emoji:'ðŸ§²',color:'#f472b6',type:'neutral',desc:'Very social'},
  nocturnal:{name:'Nocturnal',emoji:'ðŸ¦‰',color:'#1e3a8a',type:'neutral',desc:'Active at night'},
  plated:{name:'Plated',emoji:'ðŸª–',color:'#78716c',type:'good',desc:'Survives one attack'},
  ravenous:{name:'Ravenous',emoji:'ðŸ˜‹',color:'#ea580c',type:'neutral',desc:'Eats more, needs more'},
  zen:{name:'Zen',emoji:'ðŸ§˜',color:'#a78bfa',type:'good',desc:'Very brave'},
  rainbow:{name:'Rainbow',emoji:'ðŸŒˆ',color:'#ec4899',type:'special',desc:'Color shifts'},
  cannibal:{name:'Cannibal',emoji:'ðŸ’€',color:'#dc2626',type:'bad',desc:'Eats own kind'},
  immortal:{name:'Immortal',emoji:'â™¾ï¸',color:'#fcd34d',type:'special',desc:'Never ages'},
  bigstomach:{name:'Big Stomach',emoji:'ðŸ”',color:'#f59e0b',type:'good',desc:'Gets more from food'},
  smallstomach:{name:'Small Stomach',emoji:'ðŸ¥—',color:'#84cc16',type:'bad',desc:'Gets less from food'},
  traitor:{name:'Traitor',emoji:'ðŸŽ­',color:'#7c3aed',type:'special',desc:'Becomes predator on death'},
  egggiver:{name:'Egg Giver',emoji:'ðŸ£',color:'#fde047',type:'special',desc:'Spawns mutants on death'},
  fat:{name:'Fat',emoji:'ðŸ·',color:'#fdba74',type:'neutral',desc:'Slower, bigger target'},
  paper:{name:'Paper',emoji:'ðŸ“„',color:'#e2e8f0',type:'bad',desc:'Very fragile'},
  flightless:{name:'Flightless',emoji:'ðŸ§',color:'#0ea5e9',type:'bad',desc:'Much slower'},
  mechanical:{name:'Mechanical',emoji:'ðŸ¤–',color:'#6b7280',type:'special',desc:'Tireless'},
  tasty:{name:'Tasty',emoji:'ðŸ–',color:'#f87171',type:'bad',desc:'Predators target first'},
  bullied:{name:'Bullied',emoji:'ðŸ˜¢',color:'#94a3b8',type:'bad',desc:'Others avoid, easily scared'}
};

function App({wasmWorld}){
  const canvasRef=useRef(null);
  const worldRef=useRef(wasmWorld);
  const effectsRef=useRef({ripples:[],dangerZones:[],trees:[],shelters:[],nests:[],pond:null,time:0});
  const settingsRef=useRef({gameSpeed:1,cursorStrength:1,startBoids:60});
  const animRef=useRef(null);
  const[tool,setTool]=useState('food');const[showTrails,setShowTrails]=useState(false);const[cursorMode,setCursorMode]=useState('none');
  const[stats,setStats]=useState({boids:0,day:true,predators:0,bugs:0,fps:60});
  const[paused,setPaused]=useState(false);
  const[canvasSize,setCanvasSize]=useState({w:900,h:450});

  const pausedRef=useRef(false);const showTrailsRef=useRef(false);const cursorModeRef=useRef('none');
  const lastFrameTime=useRef(performance.now());const fpsRef=useRef(60);
  const cursorPosRef=useRef({x:0,y:0,active:false});

  useEffect(()=>{pausedRef.current=paused},[paused]);
  useEffect(()=>{showTrailsRef.current=showTrails},[showTrails]);
  useEffect(()=>{cursorModeRef.current=cursorMode},[cursorMode]);

  const addRipple=useCallback((x,y,color,size)=>{effectsRef.current.ripples.push(new Ripple(x,y,color,size))},[]);
  const addDangerZone=useCallback((x,y)=>{const eff=effectsRef.current;for(const z of eff.dangerZones){const dx=z.x-x,dy=z.y-y;if(dx*dx+dy*dy<1600)return}eff.dangerZones.push(new DangerZone(x,y))},[]);

  const initEffects=useCallback((w,h)=>{
    const eff=effectsRef.current;
    eff.ripples=[];eff.dangerZones=[];eff.time=0;
    eff.trees=[new Tree(w*0.1,h-30),new Tree(w*0.3,h-35),new Tree(w*0.5,h-30),new Tree(w*0.7,h-40),new Tree(w*0.9,h-30)];
    eff.shelters=[new Shelter(80,h-100),new Shelter(w-80,h-100)];
    eff.nests=[new Nest(w*0.22,h-130,0),new Nest(w*0.78,h-130,1)];
    eff.pond=new Pond(w*0.5,h-80,100,50);
  },[]);

  useEffect(()=>{
    const canvas=canvasRef.current;const ctx=canvas.getContext('2d');
    const world=worldRef.current;
    initEffects(canvas.width,canvas.height);

    const animate=()=>{
      const now=performance.now();const delta=now-lastFrameTime.current;lastFrameTime.current=now;
      fpsRef.current=fpsRef.current*0.9+(1000/delta)*0.1;

      const eff=effectsRef.current;
      const w=canvas.width,h=canvas.height;

      if(!pausedRef.current){
        const spd=Math.max(1,Math.floor(settingsRef.current.gameSpeed));
        for(let tick=0;tick<spd;tick++){
          eff.time+=16;

          // Cursor mode: 0=none, 1=attract, 2=repel
          const cMode=cursorModeRef.current==='attract'?1:cursorModeRef.current==='repel'?2:0;
          const cx=cursorPosRef.current.active?cursorPosRef.current.x:-1;
          const cy=cursorPosRef.current.active?cursorPosRef.current.y:-1;

          // Tick the Wasm simulation
          world.tick(cx,cy,cMode,settingsRef.current.cursorStrength);

          // Update visual effects
          if(eff.pond)eff.pond.update();
          eff.ripples=eff.ripples.filter(r=>r.update());
          eff.dangerZones=eff.dangerZones.filter(z=>z.update());
        }
      }

      // Get stats from Wasm
      const statsData=world.get_stats();
      const boidCount=statsData[0];
      const predatorCount=statsData[1];
      const bugCount=statsData[2];
      const dayPhase=statsData[3];
      const isDay=dayPhase>0.45;

      // Update stats display (throttled)
      if(eff.time%500<20){
        setStats({boids:Math.round(boidCount),day:isDay,predators:Math.round(predatorCount),bugs:Math.round(bugCount),fps:Math.round(fpsRef.current)});
      }

      // Render
      ctx.fillStyle=`rgba(${12+dayPhase*12},${12+dayPhase*18},${22+dayPhase*25},0.25)`;ctx.fillRect(0,0,w,h);

      // Draw visual effects
      for(const z of eff.dangerZones)z.draw(ctx);
      if(eff.pond)eff.pond.draw(ctx);
      for(const s of eff.shelters)s.draw(ctx,dayPhase);
      for(const n of eff.nests)n.draw(ctx);
      for(const t of eff.trees)t.draw(ctx,dayPhase);

      // Draw obstacles from Wasm
      const obstacleData=world.get_obstacle_data();
      for(let i=0;i<obstacleData.length;i+=2){
        const ox=obstacleData[i],oy=obstacleData[i+1];
        ctx.fillStyle='rgba(80,70,60,0.9)';ctx.beginPath();ctx.arc(ox,oy,14,0,Math.PI*2);ctx.fill();
      }

      // Draw food from Wasm
      const foodData=world.get_food_data();
      const time=eff.time;
      for(let i=0;i<foodData.length;i+=3){
        const fx=foodData[i],fy=foodData[i+1],amount=foodData[i+2];
        if(amount>0){
          const pulse=(Math.sin(time*0.003)+1)/2*0.2+0.8;
          const r=25*(amount/100)*pulse;
          const g=ctx.createRadialGradient(fx,fy,0,fx,fy,r*1.5);
          g.addColorStop(0,`rgba(100,255,150,${0.5*pulse})`);
          g.addColorStop(1,'rgba(100,255,150,0)');
          ctx.fillStyle=g;ctx.beginPath();ctx.arc(fx,fy,r*1.5,0,Math.PI*2);ctx.fill();
        }
      }

      // Draw bugs from Wasm (4 floats per bug: x, y, hue, size)
      const bugData=world.get_bug_data();
      for(let i=0;i<bugData.length;i+=4){
        const bx=bugData[i],by=bugData[i+1],hue=bugData[i+2],size=bugData[i+3];
        ctx.fillStyle=`hsla(${hue},60%,50%,0.8)`;
        ctx.beginPath();ctx.arc(bx,by,size,0,Math.PI*2);ctx.fill();
      }

      // Draw predators from Wasm (7 floats per predator: x, y, vx, vy, energy, is_leader, generation)
      const predData=world.get_predator_data();
      for(let i=0;i<predData.length;i+=7){
        const px=predData[i],py=predData[i+1],pvx=predData[i+2],pvy=predData[i+3];
        const energy=predData[i+4],isLeader=predData[i+5]>0.5,gen=predData[i+6];
        const angle=Math.atan2(pvy,pvx);
        const size=12+gen*2;
        const ng=1-dayPhase;

        ctx.save();ctx.translate(px,py);ctx.rotate(angle);
        const grad=ctx.createRadialGradient(0,0,0,0,0,25+ng*15);
        grad.addColorStop(0,`rgba(255,50,50,${0.3+ng*0.3})`);
        grad.addColorStop(1,'rgba(255,50,50,0)');
        ctx.fillStyle=grad;ctx.beginPath();ctx.arc(0,0,25+ng*15,0,Math.PI*2);ctx.fill();

        if(isLeader){
          ctx.fillStyle='rgba(255,215,0,0.9)';ctx.beginPath();
          ctx.moveTo(-6,-size*0.8);ctx.lineTo(-3,-size*0.5);ctx.lineTo(0,-size*0.8);
          ctx.lineTo(3,-size*0.5);ctx.lineTo(6,-size*0.8);ctx.lineTo(4,-size*0.4);ctx.lineTo(-4,-size*0.4);ctx.fill();
        }
        ctx.fillStyle=`hsl(0,80%,${35+energy*0.15}%)`;ctx.beginPath();
        ctx.moveTo(size,0);ctx.lineTo(-size*0.5,-size*0.6);ctx.lineTo(-size*0.3,0);ctx.lineTo(-size*0.5,size*0.6);ctx.closePath();ctx.fill();
        ctx.restore();
      }

      // Draw boids from Wasm (11 floats per boid: x, y, vx, vy, hue, energy, max_energy, size_mult, mutations, fear, state)
      const boidData=world.get_boid_data();
      for(let i=0;i<boidData.length;i+=11){
        const bx=boidData[i],by=boidData[i+1],bvx=boidData[i+2],bvy=boidData[i+3];
        const hue=boidData[i+4],energy=boidData[i+5],maxEnergy=boidData[i+6];
        const sizeMult=boidData[i+7],mutations=boidData[i+8],fear=boidData[i+9],state=boidData[i+10];

        const angle=Math.atan2(bvy,bvx);
        const baseSize=6*sizeMult;
        const isCollapsed=state===2;

        // Draw trail if enabled
        if(showTrailsRef.current&&!isCollapsed){
          ctx.strokeStyle=`hsla(${hue},70%,60%,0.3)`;ctx.lineWidth=1;
          ctx.beginPath();ctx.moveTo(bx,by);ctx.lineTo(bx-bvx*4,by-bvy*4);ctx.stroke();
        }

        // Fear glow
        if(fear>0.3){
          ctx.beginPath();ctx.arc(bx,by,baseSize*2,0,Math.PI*2);
          const glow=ctx.createRadialGradient(bx,by,0,bx,by,baseSize*2);
          glow.addColorStop(0,`rgba(255,100,100,${fear*0.4})`);glow.addColorStop(1,'rgba(255,100,100,0)');
          ctx.fillStyle=glow;ctx.fill();
        }

        // Mutation glow
        if(mutations>0){
          ctx.beginPath();ctx.arc(bx,by,baseSize*1.5,0,Math.PI*2);
          const mutGlow=ctx.createRadialGradient(bx,by,0,bx,by,baseSize*1.5);
          mutGlow.addColorStop(0,`rgba(200,100,255,${0.2+mutations*0.05})`);mutGlow.addColorStop(1,'rgba(200,100,255,0)');
          ctx.fillStyle=mutGlow;ctx.fill();
        }

        ctx.save();ctx.translate(bx,by);ctx.rotate(angle);

        // Collapsed state
        if(isCollapsed){
          ctx.fillStyle=`hsla(${hue},40%,40%,0.7)`;
          ctx.beginPath();ctx.ellipse(0,0,baseSize,baseSize*0.5,0,0,Math.PI*2);ctx.fill();
        }else{
          // Normal boid
          const lightness=45+dayPhase*15;
          ctx.fillStyle=`hsla(${hue},70%,${lightness}%,0.9)`;
          ctx.beginPath();ctx.moveTo(baseSize,0);ctx.lineTo(-baseSize*0.6,-baseSize*0.5);
          ctx.lineTo(-baseSize*0.3,0);ctx.lineTo(-baseSize*0.6,baseSize*0.5);ctx.closePath();ctx.fill();

          // Energy indicator
          const energyRatio=energy/maxEnergy;
          if(energyRatio<0.3){
            ctx.fillStyle=`rgba(255,${energyRatio*255},0,0.6)`;
            ctx.beginPath();ctx.arc(0,0,2,0,Math.PI*2);ctx.fill();
          }
        }
        ctx.restore();
      }

      // Draw ripples
      for(const r of eff.ripples)r.draw(ctx);

      // Draw cursor indicator
      if(cursorPosRef.current.active&&cursorModeRef.current!=='none'){
        ctx.strokeStyle=cursorModeRef.current==='attract'?'rgba(100,255,150,0.4)':'rgba(255,100,100,0.4)';
        ctx.lineWidth=2;ctx.beginPath();
        ctx.arc(cursorPosRef.current.x,cursorPosRef.current.y,100*settingsRef.current.cursorStrength,0,Math.PI*2);
        ctx.stroke();
      }

      // Paused overlay
      if(pausedRef.current){
        ctx.fillStyle='rgba(0,0,0,0.3)';ctx.fillRect(0,0,w,h);
        ctx.fillStyle='white';ctx.font='48px sans-serif';ctx.textAlign='center';ctx.fillText('PAUSED',w/2,h/2);
      }

      animRef.current=requestAnimationFrame(animate);
    };

    ctx.fillStyle='rgb(12,12,22)';ctx.fillRect(0,0,canvas.width,canvas.height);
    animate();
    return()=>{if(animRef.current)cancelAnimationFrame(animRef.current)};
  },[initEffects,addRipple,addDangerZone]);

  const handleClick=e=>{
    const rect=canvasRef.current.getBoundingClientRect();
    const x=(e.clientX-rect.left)*(canvasRef.current.width/rect.width);
    const y=(e.clientY-rect.top)*(canvasRef.current.height/rect.height);
    const world=worldRef.current;

    switch(tool){
      case'obstacle':world.add_obstacle(x,y);break;
      case'predator':world.add_predator(x,y);addRipple(x,y,'rgb(255,50,50)',35);break;
      case'food':world.add_food(x,y);addRipple(x,y,'rgb(100,255,150)',25);break;
      case'boid':world.add_boids(x,y,8);addRipple(x,y,'rgb(150,200,255)',40);break;
    }
  };

  const handleMouseMove=e=>{
    const rect=canvasRef.current.getBoundingClientRect();
    cursorPosRef.current.x=(e.clientX-rect.left)*(canvasRef.current.width/rect.width);
    cursorPosRef.current.y=(e.clientY-rect.top)*(canvasRef.current.height/rect.height);
    cursorPosRef.current.active=true;
  };

  const handleMouseLeave=()=>{cursorPosRef.current.active=false};

  const resizeCanvas=(newW,newH)=>{
    setCanvasSize({w:newW,h:newH});
    worldRef.current.reset(newW,newH,settingsRef.current.startBoids);
    initEffects(newW,newH);
  };

  const resetWorld=()=>{
    worldRef.current.reset(canvasSize.w,canvasSize.h,settingsRef.current.startBoids);
    initEffects(canvasSize.w,canvasSize.h);
  };

  const tools=[{id:'food',label:'+'},{id:'obstacle',label:'O'},{id:'predator',label:'P'},{id:'boid',label:'B'}];

  return(
    <div className="flex flex-col items-center gap-1 p-2 bg-gray-900 min-h-screen">
      <div className="flex items-center gap-3 flex-wrap justify-center">
        <h1 className="text-base font-bold text-cyan-400">Living World <span className="text-xs text-purple-400">(Wasm)</span></h1>
        <span className="text-gray-500 text-xs">{stats.day?'D':'N'} | {stats.boids} boids | {stats.predators} pred | {stats.bugs} bugs | {stats.fps}fps</span>
      </div>

      <canvas ref={canvasRef} width={canvasSize.w} height={canvasSize.h} onClick={handleClick} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave} className="border border-gray-700 rounded cursor-crosshair"/>

      <div className="flex flex-wrap justify-center items-center gap-1">
        <button onClick={()=>setPaused(p=>!p)} className={`px-2 py-0.5 rounded text-xs font-bold ${paused?'bg-green-600':'bg-yellow-600'}`}>{paused?'Play':'Pause'}</button>
        {tools.map(t=><button key={t.id} onClick={()=>setTool(t.id)} className={`w-7 h-7 rounded text-sm ${tool===t.id?'bg-cyan-600':'bg-gray-700 hover:bg-gray-600'}`} title={t.id}>{t.label}</button>)}
        <span className="mx-1 text-gray-600">|</span>
        {['none','attract','repel'].map(m=><button key={m} onClick={()=>setCursorMode(m)} className={`px-2 py-0.5 rounded text-xs ${cursorMode===m?m==='attract'?'bg-green-600':m==='repel'?'bg-red-600':'bg-gray-600':'bg-gray-700'}`}>{m==='none'?'Off':m==='attract'?'Attract':'Repel'}</button>)}
        <span className="mx-1 text-gray-600">|</span>
        <button onClick={()=>setShowTrails(t=>!t)} className={`px-2 py-0.5 rounded text-xs ${showTrails?'bg-purple-600':'bg-gray-700'}`}>Trails</button>
        <button onClick={resetWorld} className="px-2 py-0.5 bg-gray-700 rounded text-xs">Reset</button>
      </div>

      <div className="w-full max-w-3xl mt-1 p-2 bg-gray-800 rounded border border-gray-700">
        <div className="flex flex-wrap gap-4 justify-center items-center text-xs">
          <label className="flex items-center gap-1"><span className="text-gray-400">Speed</span><input type="number" defaultValue={1} step={0.5} onBlur={e=>{settingsRef.current.gameSpeed=Math.max(0.5,Math.min(10,parseFloat(e.target.value)||1))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Start Boids</span><input type="number" defaultValue={60} onBlur={e=>{settingsRef.current.startBoids=Math.max(10,Math.min(500,parseInt(e.target.value)||60))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Vortex</span><input type="range" min="0.1" max="3" step="0.1" defaultValue="1" onChange={e=>{settingsRef.current.cursorStrength=parseFloat(e.target.value)}} className="w-16"/></label>
          <div className="flex items-center gap-1"><span className="text-gray-400">Size</span>
            <button onClick={()=>resizeCanvas(900,450)} className={`px-1 py-0.5 rounded ${canvasSize.w===900?'bg-cyan-600':'bg-gray-700'}`}>M</button>
            <button onClick={()=>resizeCanvas(1200,550)} className={`px-1 py-0.5 rounded ${canvasSize.w===1200?'bg-cyan-600':'bg-gray-700'}`}>L</button>
            <button onClick={()=>resizeCanvas(1400,650)} className={`px-1 py-0.5 rounded ${canvasSize.w===1400?'bg-cyan-600':'bg-gray-700'}`}>XL</button>
          </div>
        </div>
      </div>
    </div>
  );
}

// Initialize Wasm and render
async function main(){
  await init();
  const world=new WasmWorld(900,450,60);
  ReactDOM.createRoot(document.getElementById('root')).render(<App wasmWorld={world}/>);
}
main().catch(console.error);
</script>
</body>
</html>
