<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Living World - Boids</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>body{margin:0;background:#111827;}input[type=number],input[type=range]{-moz-appearance:textfield;}input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}.scroll-stable{overflow-anchor:none;}</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const{useState,useEffect,useRef,useCallback}=React;
const MAX_SPEED=4,MAX_FORCE=0.15;

// Spatial hash for optimization
class SpatialHash{
  constructor(cellSize=50){this.cellSize=cellSize;this.cells=new Map()}
  clear(){this.cells.clear()}
  getKey(x,y){return`${Math.floor(x/this.cellSize)},${Math.floor(y/this.cellSize)}`}
  insert(obj){const key=this.getKey(obj.position.x,obj.position.y);if(!this.cells.has(key))this.cells.set(key,[]);this.cells.get(key).push(obj)}
  getNearby(x,y,radius=1){const results=[];const cx=Math.floor(x/this.cellSize),cy=Math.floor(y/this.cellSize);for(let dx=-radius;dx<=radius;dx++)for(let dy=-radius;dy<=radius;dy++){const key=`${cx+dx},${cy+dy}`;if(this.cells.has(key))results.push(...this.cells.get(key))}return results}
}

// Vector2 object pool to reduce GC pressure
const vecPool=[];const POOL_SIZE=200;for(let i=0;i<POOL_SIZE;i++)vecPool.push({x:0,y:0,inUse:false});
let poolIndex=0;
function getVec(x=0,y=0){const v=vecPool[poolIndex];poolIndex=(poolIndex+1)%POOL_SIZE;v.x=x;v.y=y;return v}

class Vector2{
  constructor(x=0,y=0){this.x=x;this.y=y}
  // Immutable methods (return new Vector2)
  add(v){return new Vector2(this.x+v.x,this.y+v.y)}
  sub(v){return new Vector2(this.x-v.x,this.y-v.y)}
  mult(n){return new Vector2(this.x*n,this.y*n)}
  div(n){return n===0?new Vector2():new Vector2(this.x/n,this.y/n)}
  normalize(){const m=this.mag();return m===0?new Vector2():this.div(m)}
  limit(max){const msq=this.magSq();return msq>max*max?this.normalize().mult(max):this.copy()}
  copy(){return new Vector2(this.x,this.y)}
  // Mutable methods (modify in place, return this for chaining)
  set(x,y){this.x=x;this.y=y;return this}
  addM(v){this.x+=v.x;this.y+=v.y;return this}
  subM(v){this.x-=v.x;this.y-=v.y;return this}
  multM(n){this.x*=n;this.y*=n;return this}
  divM(n){if(n!==0){this.x/=n;this.y/=n}return this}
  normalizeM(){const m=this.mag();if(m>0){this.x/=m;this.y/=m}return this}
  limitM(max){const msq=this.magSq();if(msq>max*max){const m=Math.sqrt(msq);this.x=this.x/m*max;this.y=this.y/m*max}return this}
  zero(){this.x=0;this.y=0;return this}
  // Non-allocating calculations
  mag(){return Math.sqrt(this.x*this.x+this.y*this.y)}
  magSq(){return this.x*this.x+this.y*this.y}
  dist(v){const dx=this.x-v.x,dy=this.y-v.y;return Math.sqrt(dx*dx+dy*dy)}
  distSq(v){const dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy}
  static fromAngle(a,m=1){return new Vector2(Math.cos(a)*m,Math.sin(a)*m)}
}

class Ripple{
  constructor(x,y,color,maxRadius=40){this.position=new Vector2(x,y);this.radius=5;this.maxRadius=maxRadius;this.color=color;this.alpha=0.8}
  update(){this.radius+=2;this.alpha-=0.03;return this.alpha>0}
  draw(ctx){ctx.strokeStyle=this.color.replace(')',`,${this.alpha})`).replace('rgb','rgba');ctx.lineWidth=2;ctx.beginPath();ctx.arc(this.position.x,this.position.y,this.radius,0,Math.PI*2);ctx.stroke()}
}

class DangerZone{
  constructor(x,y){this.position=new Vector2(x,y);this.intensity=1;this.radius=70}
  update(){this.intensity-=0.002;return this.intensity>0}
  draw(ctx){const g=ctx.createRadialGradient(this.position.x,this.position.y,0,this.position.x,this.position.y,this.radius);g.addColorStop(0,`rgba(255,0,0,${this.intensity*0.1})`);g.addColorStop(1,'rgba(255,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(this.position.x,this.position.y,this.radius,0,Math.PI*2);ctx.fill()}
}

class Shelter{
  constructor(x,y){this.position=new Vector2(x,y);this.radius=50;this.capacity=15;this.occupants=0}
  contains(pos){return this.position.distSq(pos)<this.radius*this.radius}
  draw(ctx,dayPhase){ctx.fillStyle=`rgba(40,35,30,${0.8+(1-dayPhase)*0.2})`;ctx.beginPath();ctx.arc(this.position.x,this.position.y+10,this.radius,Math.PI,0);ctx.fill();ctx.strokeStyle='rgba(100,200,100,0.2)';ctx.setLineDash([5,5]);ctx.beginPath();ctx.arc(this.position.x,this.position.y,this.radius,0,Math.PI*2);ctx.stroke();ctx.setLineDash([])}
}

class Nest{
  constructor(x,y,species){this.position=new Vector2(x,y);this.species=species;this.births=0}
  draw(ctx){ctx.fillStyle=`hsla(${this.species===0?30:45},40%,30%,0.6)`;ctx.beginPath();ctx.ellipse(this.position.x,this.position.y,20,12,0,0,Math.PI*2);ctx.fill()}
}

class Tree{
  constructor(x,y){this.position=new Vector2(x,y);this.height=60+Math.random()*40;this.width=40+Math.random()*20;this.perch=new Perch(x,y-this.height+15,this.width*0.8)}
  spawnBug(){return new Bug(this.position.x+(Math.random()-0.5)*this.width,this.position.y-this.height*0.5)}
  draw(ctx,dayPhase){ctx.fillStyle=`rgba(60,40,30,${0.8+dayPhase*0.2})`;ctx.fillRect(this.position.x-8,this.position.y-this.height,16,this.height);ctx.fillStyle=`rgba(${30+dayPhase*20},${80+dayPhase*40},${30+dayPhase*20},0.9)`;ctx.beginPath();ctx.ellipse(this.position.x,this.position.y-this.height,this.width/2,this.height*0.4,0,0,Math.PI*2);ctx.fill();ctx.fillStyle=`rgba(${20+dayPhase*15},${60+dayPhase*30},${20+dayPhase*15},0.8)`;ctx.beginPath();ctx.ellipse(this.position.x-10,this.position.y-this.height+10,this.width*0.3,this.height*0.25,0,0,Math.PI*2);ctx.fill();this.perch.draw(ctx,dayPhase)}
}

class Pond{
  constructor(x,y,w,h){this.position=new Vector2(x,y);this.width=w;this.height=h;this.fish=[];this.maxFish=8}
  update(){if(this.fish.length<this.maxFish&&Math.random()<0.01)this.fish.push({x:(Math.random()-0.5)*this.width*0.8,y:(Math.random()-0.5)*this.height*0.6,phase:Math.random()*Math.PI*2});for(let f of this.fish){f.x+=Math.sin(f.phase)*0.3;f.phase+=0.02}}
  tryFish(boid){if(this.fish.length===0)return{caught:false};if(Math.random()<0.1)return{caught:false,drowned:true};this.fish.pop();return{caught:true,food:25}}
  draw(ctx,time){const g=ctx.createRadialGradient(this.position.x,this.position.y,0,this.position.x,this.position.y,Math.max(this.width,this.height)/2);g.addColorStop(0,'rgba(30,80,120,0.8)');g.addColorStop(0.7,'rgba(40,100,140,0.7)');g.addColorStop(1,'rgba(50,120,160,0.5)');ctx.fillStyle=g;ctx.beginPath();ctx.ellipse(this.position.x,this.position.y,this.width/2,this.height/2,0,0,Math.PI*2);ctx.fill();ctx.fillStyle='rgba(255,150,50,0.7)';for(let f of this.fish){ctx.beginPath();ctx.ellipse(this.position.x+f.x,this.position.y+f.y,4,2,Math.sin(f.phase)*0.3,0,Math.PI*2);ctx.fill()}}
}

class Perch{
  constructor(x,y,width){this.position=new Vector2(x,y);this.width=width;this.occupants=[];this.maxOccupants=Math.floor(width/12)}
  getRestSpot(){if(this.occupants.length>=this.maxOccupants)return null;const spacing=this.width/(this.maxOccupants+1);return new Vector2(this.position.x-this.width/2+spacing*(this.occupants.length+1),this.position.y-5)}
  draw(ctx,dayPhase){ctx.strokeStyle=`rgba(80,60,40,${0.6+dayPhase*0.2})`;ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(this.position.x-this.width/2,this.position.y);ctx.lineTo(this.position.x+this.width/2,this.position.y);ctx.stroke()}
}

class FoodSource{
  constructor(x,y){this.position=new Vector2(x,y);this.amount=100;this.phase=Math.random()*Math.PI*2}
  draw(ctx,time,season){if(this.amount<=0)return;const pulse=(Math.sin(time*0.003+this.phase)+1)/2*0.2+0.8;const sm=season>0.75||season<0.1?0.5:1;const r=25*(this.amount/100)*pulse*sm;const g=ctx.createRadialGradient(this.position.x,this.position.y,0,this.position.x,this.position.y,r*1.5);g.addColorStop(0,`rgba(100,255,150,${0.5*pulse})`);g.addColorStop(1,'rgba(100,255,150,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(this.position.x,this.position.y,r*1.5,0,Math.PI*2);ctx.fill()}
}

class Bug{
  constructor(x,y){this.position=new Vector2(x,y);this.velocity=Vector2.fromAngle(Math.random()*Math.PI*2,1+Math.random());this.energy=20;this.size=2+Math.random()*2;this.hue=Math.random()>0.5?60:120;this.lifetime=500+Math.random()*500}
  update(w,h,obstacles){
    this.lifetime--;if(this.lifetime<=0||this.energy<=0)return false;
    this.velocity=this.velocity.add(Vector2.fromAngle(Math.random()*Math.PI*2,0.15)).limit(2);
    const nextPos=this.position.add(this.velocity);
    for(const o of obstacles){if(nextPos.distSq(o)<18*18){this.velocity=this.position.sub(o).normalize().mult(2);break}}
    this.position=this.position.add(this.velocity);
    if(this.position.x<0)this.position.x=w;if(this.position.x>w)this.position.x=0;if(this.position.y<0)this.position.y=h;if(this.position.y>h)this.position.y=0;return true
  }
  draw(ctx){ctx.fillStyle=`hsla(${this.hue},60%,50%,0.8)`;ctx.beginPath();ctx.arc(this.position.x,this.position.y,this.size,0,Math.PI*2);ctx.fill()}
}

class Corpse{
  constructor(x,y,species){this.position=new Vector2(x,y);this.species=species;this.nutrition=40;this.decay=1}
  update(){this.decay-=0.001;return this.decay>0&&this.nutrition>0}
  draw(ctx){ctx.fillStyle=`rgba(100,80,60,${this.decay*0.6})`;ctx.beginPath();ctx.arc(this.position.x,this.position.y,4*this.decay,0,Math.PI*2);ctx.fill()}
}

class Predator{
  constructor(x,y,packId=0,gen=0,mutations={}){this.position=new Vector2(x,y);this.velocity=Vector2.fromAngle(Math.random()*Math.PI*2,2);this.acceleration=new Vector2();this.baseSpeed=3.5+gen*0.3;this.maxSpeed=this.baseSpeed;this.maxForce=0.1+gen*0.02;this.energy=100;this.packId=packId;this.isLeader=false;this.generation=gen;this.kills=0;this.mutations=mutations;this.targetBoid=null;this.id=Math.random().toString(36).substr(2,9);this.applyMutationEffects()}
  applyMutationEffects(){
    // Speed mutations
    if(this.mutations.speedy)this.baseSpeed*=1.3;if(this.mutations.swift)this.baseSpeed*=1.15;if(this.mutations.fat)this.baseSpeed*=0.8;
    // Max force (turning)
    if(this.mutations.swift)this.maxForce*=1.2;if(this.mutations.wise)this.maxForce*=1.1;
    // Size
    this.sizeMultiplier=1;if(this.mutations.giant)this.sizeMultiplier=1.4;if(this.mutations.tiny)this.sizeMultiplier=0.7;
  }
  getMutationList(){return Object.keys(this.mutations)}
  getMutationCount(){return Object.keys(this.mutations).length}
  edges(w,h){if(this.position.x>w)this.position.x=0;if(this.position.x<0)this.position.x=w;if(this.position.y>h)this.position.y=0;if(this.position.y<0)this.position.y=h}
  hunt(boids,predators,shelters,dayPhase,spatialHash){
    const agg=1+(1-dayPhase)*0.5;this.maxSpeed=this.baseSpeed+(1-dayPhase)*2;
    const pack=predators.filter(p=>p.packId===this.packId);const leader=pack.find(p=>p.isLeader)||pack[0];if(leader)leader.isLeader=true;
    let target=null,targetDist=Infinity;
    const px=this.position.x,py=this.position.y;
    const nearby=spatialHash.getNearby(px,py,3);
    const maxDistSq=22500*agg*agg;
    for(let i=0;i<nearby.length;i++){
      const boid=nearby[i];
      if(!(boid instanceof Boid))continue;
      const bx=boid.position.x,by=boid.position.y;
      let inShelter=false;for(let j=0;j<shelters.length;j++){const s=shelters[j];const dx=s.position.x-bx,dy=s.position.y-by;if(dx*dx+dy*dy<s.radius*s.radius){inShelter=true;break}}
      if(inShelter)continue;
      const dx=px-bx,dy=py-by,d=dx*dx+dy*dy;
      let priority=d;if(boid.mutations.tasty)priority*=0.25;if(boid.isCollapsed)priority*=0.09;priority*=(1-boid.energy/100)*0.5+0.5;
      if(d<maxDistSq&&priority<targetDist){targetDist=priority;target=boid}
    }
    this.targetBoid=target;
    if(target){
      const tx=target.position.x+target.velocity.x*8,ty=target.position.y+target.velocity.y*8;
      let sx=tx-px,sy=ty-py,sm=Math.sqrt(sx*sx+sy*sy);
      if(sm>0){sx/=sm;sy/=sm}
      sx=sx*this.maxSpeed-this.velocity.x;sy=sy*this.maxSpeed-this.velocity.y;
      sm=Math.sqrt(sx*sx+sy*sy);const sl=this.maxForce*agg;if(sm>sl){sx=sx/sm*sl;sy=sy/sm*sl}
      this.acceleration.x+=sx;this.acceleration.y+=sy;
      let catchD=target.mutations.camouflage||target.mutations.silent?8:target.mutations.fat?15:target.mutations.chonky?14:12;
      if(target.mutations.acrobat)catchD*=0.7;if(target.mutations.swift)catchD*=0.85;
      const tdx=px-target.position.x,tdy=py-target.position.y;
      const actualDist=Math.sqrt(tdx*tdx+tdy*tdy);
      if(actualDist<catchD){
        // Near-death experience - chance to evolve fighter mutation
        if(!target.mutations.fighter&&!target.nearDeathTriggered){target.nearDeathCount=(target.nearDeathCount||0)+1;target.nearDeathTriggered=true;if(Math.random()<0.03){target.mutations.fighter=true;target.canFight=true;target.justEvolvedFighter=true}}
        // Electric shock
        if(target.mutations.electric&&Math.random()<0.4){this.energy-=20;target.fear=0.8;return null}
        // Fighter mutation - 50% chance to fight, 40% of fights kill the predator
        if(target.mutations.fighter&&Math.random()<0.5){target.justFoughtOff=true;if(Math.random()<0.4){this.killedByFighter=true;target.justKilledPredator=true}else{this.energy-=25}target.fear=0.3;return null}
        // Lucky mutation gives better odds
        if(target.mutations.lucky&&Math.random()<0.3){target.fear=1;return null}
        // Acrobat dodge
        if(target.mutations.acrobat&&Math.random()<0.25){target.fear=0.8;return null}
        // Plated armor
        if(target.mutations.plated&&target.hasArmor){target.hasArmor=false;target.mutations.plated=false;target.fear=1;target.armorJustBroke=true;this.energy=Math.min(150,this.energy+10);return null}
        // Catch success
        let catchChance=target.mutations.paper?1:target.mutations.tasty?0.95:0.9;
        if(target.mutations.cursed)catchChance+=0.1;if(target.mutations.fragile)catchChance+=0.05;
        if(Math.random()<catchChance){
          this.energy=Math.min(150,this.energy+(target.mutations.tasty?60:45));this.kills++;
          if(Math.random()<0.05&&Object.keys(target.mutations).length>0){const muts=Object.keys(target.mutations);const inheritMut=muts[Math.floor(Math.random()*muts.length)];if(!['traitor','egggiver','phoenix','mimic'].includes(inheritMut))this.mutations[inheritMut]=true}
          return target
        }else{target.fear=1;target.nearDeathTriggered=true}
      }
    }
    return null
  }
  update(w,h,obstacles,cursorPos,cursorMode,cursorStrength,vortexPredators){
    this.energy-=0.04;if(this.mutations.healer)this.energy=Math.min(150,this.energy+0.01);
    const px=this.position.x,py=this.position.y;
    for(let i=0;i<obstacles.length;i++){const o=obstacles[i];const dx=px-o.x,dy=py-o.y,dsq=dx*dx+dy*dy;if(dsq<900){const m=Math.sqrt(dsq);if(m>0){this.acceleration.x+=dx/m*MAX_FORCE*3;this.acceleration.y+=dy/m*MAX_FORCE*3}}}
    // Cursor vortex for predators
    if(vortexPredators&&cursorPos&&cursorMode!=='none'){const cdx=cursorPos.x-px,cdy=cursorPos.y-py,cdsq=cdx*cdx+cdy*cdy;if(cdsq<10000){const cd=Math.sqrt(cdsq);let ccx=cursorMode==='attract'?cdx:-cdx,ccy=cursorMode==='attract'?cdy:-cdy,ccm=Math.sqrt(ccx*ccx+ccy*ccy);if(ccm>0){ccx/=ccm;ccy/=ccm}const force=MAX_FORCE*2*cursorStrength*(1-cd/100);this.acceleration.x+=ccx*force;this.acceleration.y+=ccy*force}}
    this.velocity.addM(this.acceleration).limitM(this.maxSpeed);this.position.addM(this.velocity);this.acceleration.zero();this.edges(w,h);return this.energy>0
  }
  draw(ctx,time,dayPhase){const angle=Math.atan2(this.velocity.y,this.velocity.x);const size=12+this.generation*2;ctx.save();ctx.translate(this.position.x,this.position.y);ctx.rotate(angle);const ng=1-dayPhase;const g=ctx.createRadialGradient(0,0,0,0,0,25+ng*15);g.addColorStop(0,`rgba(255,50,50,${0.3+ng*0.3})`);g.addColorStop(1,'rgba(255,50,50,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(0,0,25+ng*15,0,Math.PI*2);ctx.fill();if(this.isLeader){ctx.fillStyle='rgba(255,215,0,0.9)';ctx.beginPath();ctx.moveTo(-6,-size*0.8);ctx.lineTo(-3,-size*0.5);ctx.lineTo(0,-size*0.8);ctx.lineTo(3,-size*0.5);ctx.lineTo(6,-size*0.8);ctx.lineTo(4,-size*0.4);ctx.lineTo(-4,-size*0.4);ctx.fill()}ctx.fillStyle=`hsl(0,80%,${35+this.energy*0.15}%)`;ctx.beginPath();ctx.moveTo(size,0);ctx.lineTo(-size*0.5,-size*0.6);ctx.lineTo(-size*0.3,0);ctx.lineTo(-size*0.5,size*0.6);ctx.closePath();ctx.fill();if(Object.keys(this.mutations).length>0){ctx.strokeStyle='rgba(255,200,0,0.5)';ctx.lineWidth=2;ctx.beginPath();ctx.arc(0,0,size+4,0,Math.PI*2);ctx.stroke()}ctx.restore()}
}

class Boid{
  constructor(x,y,species=0,parentTraits=null,isHybrid=false,parentMutations=null,mutMult=1,forceMutation=null){
    this.position=new Vector2(x,y);this.velocity=Vector2.fromAngle(Math.random()*Math.PI*2,2+Math.random()*2);this.acceleration=new Vector2();this.species=species;this.isHybrid=isHybrid;this.id=Math.random().toString(36).substr(2,9);
    this.hue=isHybrid?120+Math.random()*30:species===0?190+Math.random()*30:40+Math.random()*30;
    this.trail=[];this.fear=0;this.energy=50+Math.random()*50;this.fatigue=0;this.age=0;this.maxAge=8000+Math.random()*4000;
    this.isPerching=false;this.perchTarget=null;this.isCollapsed=false;this.collapseTimer=0;this.matingDisplay=0;this.friend=null;this.friendBond=0;
    this.maxEnergy=100;this.energyDrain=1;this.isFishing=false;this.fishTimer=0;
    if(parentTraits){this.bravery=Math.max(0,Math.min(1,parentTraits.bravery+(Math.random()-0.5)*0.2));this.hunger=Math.max(0,Math.min(1,parentTraits.hunger+(Math.random()-0.5)*0.2));this.laziness=Math.max(0,Math.min(1,parentTraits.laziness+(Math.random()-0.5)*0.2));this.sociability=Math.max(0,Math.min(1,parentTraits.sociability+(Math.random()-0.5)*0.2))}
    else{this.bravery=Math.random();this.hunger=Math.random();this.laziness=Math.random();this.sociability=Math.random()}
    if(isHybrid){const traits=['bravery','hunger','laziness','sociability'];this[traits[Math.floor(Math.random()*4)]]=Math.min(1,this[traits[0]]+0.2);this.maxAge*=1.1}
    this.mutations={};
    if(parentMutations){const{parent1Muts,parent2Muts}=parentMutations;const all=new Set([...Object.keys(parent1Muts||{}),...Object.keys(parent2Muts||{})]);for(const m of all){if(m==='egggiver')continue;const p1=parent1Muts&&parent1Muts[m],p2=parent2Muts&&parent2Muts[m];if(p1&&p2)this.mutations[m]=true;else if((p1||p2)&&Math.random()<0.5)this.mutations[m]=true}}
    if(forceMutation)this.mutations[forceMutation]=true;
    else if(Math.random()<0.03*mutMult){const possible=Object.keys(mutationInfo).filter(m=>m!=='egggiver'&&m!=='phoenix'&&m!=='mimic');const avail=possible.filter(m=>!this.mutations[m]);if(avail.length>0)this.mutations[avail[Math.floor(Math.random()*avail.length)]]=true}
    this.hasPhoenix=!!this.mutations.phoenix;this.nearDeathCount=0
    this.applyMutationEffects()
  }
  applyMutationEffects(){
    this.sizeMultiplier=1;if(this.mutations.giant)this.sizeMultiplier=1.5;if(this.mutations.tiny)this.sizeMultiplier=0.6;if(this.mutations.fat)this.sizeMultiplier=1.3;if(this.mutations.chonky)this.sizeMultiplier*=1.2;
    this.speedMultiplier=1;if(this.mutations.speedy)this.speedMultiplier=1.4;if(this.mutations.tiny)this.speedMultiplier*=1.2;if(this.mutations.giant)this.speedMultiplier*=0.85;if(this.mutations.fat)this.speedMultiplier*=0.7;if(this.mutations.flightless)this.speedMultiplier*=0.5;if(this.mutations.mechanical)this.speedMultiplier*=1.1;if(this.mutations.swift)this.speedMultiplier*=1.15;if(this.mutations.wings)this.speedMultiplier*=1.3;if(this.mutations.chonky)this.speedMultiplier*=0.8;
    if(this.mutations.longlived)this.maxAge*=1.5;if(this.mutations.immortal)this.maxAge=Infinity;if(this.mutations.fragile)this.maxAge*=0.6;
    this.fatigueResistance=this.mutations.tough?0.5:this.mutations.mechanical?0.3:this.mutations.wings?0.4:this.mutations.hermit?0.4:1;if(this.mutations.paper)this.fatigueResistance=2;if(this.mutations.sleepy)this.fatigueResistance*=1.5;if(this.mutations.stubborn)this.fatigueResistance=0;
    if(this.mutations.zen)this.bravery=Math.min(1,this.bravery+0.4);if(this.mutations.wise)this.bravery=Math.min(1,this.bravery+0.3);
    this.isNocturnal=!!this.mutations.nocturnal;this.hasArmor=!!this.mutations.plated;this.ravenous=!!this.mutations.ravenous;this.hasCamouflage=!!this.mutations.camouflage||!!this.mutations.silent;
    if(this.mutations.magnetic)this.sociability=Math.min(1,this.sociability+0.5);if(this.mutations.bullied)this.sociability=Math.max(0,this.sociability-0.4);if(this.mutations.hermit)this.sociability=Math.max(0,this.sociability-0.6);if(this.mutations.leader)this.sociability=Math.min(1,this.sociability+0.3);
    this.fertilityBonus=this.mutations.fertile?2:1;this.isAggressive=!!this.mutations.aggressive;this.isRainbow=!!this.mutations.rainbow;this.isGlowing=!!this.mutations.glowing||!!this.mutations.mechanical||!!this.mutations.electric;
    this.maxEnergy=this.mutations.bigstomach?200:this.mutations.smallstomach?50:100;
    this.energyDrain=this.mutations.immortal?3:this.mutations.smallstomach?0.66:this.mutations.mechanical?0.5:this.mutations.fluffy?0.7:1;if(this.mutations.vampire)this.energyDrain*=1.3;
    if(this.mutations.bullied)this.fear=Math.min(1,this.fear+0.3);
    // Fighter, scout, lucky, acrobat affect catch chance in predator.hunt()
    this.canFight=!!this.mutations.fighter;this.isScout=!!this.mutations.scout;this.isLucky=!!this.mutations.lucky;this.isAcrobat=!!this.mutations.acrobat;this.isElectric=!!this.mutations.electric;this.isLoud=!!this.mutations.loud;this.isCursed=!!this.mutations.cursed;
  }
  getMutationCount(){return Object.keys(this.mutations).length}
  getMutationList(){return Object.keys(this.mutations)}
  edges(w,h,predators){
    const margin=30,px=this.position.x,py=this.position.y;let dominated=false;
    for(let i=0;i<predators.length;i++){const p=predators[i];if(p.targetBoid===this){const dx=px-p.position.x,dy=py-p.position.y;if(dx*dx+dy*dy<10000){dominated=true;break}}}
    if(dominated){
      if(px<margin)this.acceleration.x+=MAX_FORCE*3;
      if(px>w-margin)this.acceleration.x-=MAX_FORCE*3;
      if(py<margin)this.acceleration.y+=MAX_FORCE*3;
      if(py>h-margin)this.acceleration.y-=MAX_FORCE*3;
    }
    if(px>w)this.position.x=0;else if(px<0)this.position.x=w;
    if(py>h)this.position.y=0;else if(py<0)this.position.y=h;
  }
  flock(nearbyBoids,obstacles,predators,dangerZones,shelters,perches,dayPhase,cursorPos,cursorMode,pond,cursorStrength){
    if(this.isFishing||this.isCollapsed||this.isPerching)return;
    if(this.fatigue>150){this.isCollapsed=true;this.collapseTimer=100;this.velocity.zero();return}

    const px=this.position.x,py=this.position.y,vx=this.velocity.x,vy=this.velocity.y;
    let sepX=0,sepY=0,aliX=0,aliY=0,cohX=0,cohY=0,sepCt=0,aliCt=0,cohCt=0;
    const cohRadius=50*(1+(1-dayPhase)*0.5+this.sociability*0.3),cohRadiusSq=cohRadius*cohRadius;

    // Separation, alignment, cohesion - optimized with inline math
    for(let i=0,len=nearbyBoids.length;i<len;i++){
      const other=nearbyBoids[i];
      if(other===this||other.isPerching||other.isCollapsed)continue;
      const ox=other.position.x,oy=other.position.y;
      const dx=px-ox,dy=py-oy,dsq=dx*dx+dy*dy;
      if(dsq<625){const inv=1/(dsq+0.001);sepX+=dx*inv;sepY+=dy*inv;sepCt++}
      const canFlock=this.isHybrid||other.isHybrid||other.species===this.species;
      if(canFlock){if(dsq<2500){aliX+=other.velocity.x;aliY+=other.velocity.y;aliCt++}if(dsq<cohRadiusSq){cohX+=ox;cohY+=oy;cohCt++}}
    }

    let ax=0,ay=0;
    if(sepCt>0){let sx=sepX/sepCt,sy=sepY/sepCt,sm=Math.sqrt(sx*sx+sy*sy);if(sm>0){sx/=sm;sy/=sm}sx=sx*MAX_SPEED-vx;sy=sy*MAX_SPEED-vy;sm=Math.sqrt(sx*sx+sy*sy);if(sm>MAX_FORCE){sx=sx/sm*MAX_FORCE;sy=sy/sm*MAX_FORCE}ax+=sx*1.8;ay+=sy*1.8}
    if(aliCt>0){let lx=aliX/aliCt,ly=aliY/aliCt,lm=Math.sqrt(lx*lx+ly*ly);if(lm>0){lx/=lm;ly/=lm}lx=lx*MAX_SPEED-vx;ly=ly*MAX_SPEED-vy;lm=Math.sqrt(lx*lx+ly*ly);if(lm>MAX_FORCE){lx=lx/lm*MAX_FORCE;ly=ly/lm*MAX_FORCE}ax+=lx;ay+=ly}
    if(cohCt>0){let cx=cohX/cohCt-px,cy=cohY/cohCt-py,cm=Math.sqrt(cx*cx+cy*cy);if(cm>0){cx/=cm;cy/=cm}cx=cx*MAX_SPEED-vx;cy=cy*MAX_SPEED-vy;cm=Math.sqrt(cx*cx+cy*cy);if(cm>MAX_FORCE){cx=cx/cm*MAX_FORCE;cy=cy/cm*MAX_FORCE}const sm=1+this.sociability*0.3;ax+=cx*sm;ay+=cy*sm}

    // Flee from predators - inline optimized
    let fleeX=0,fleeY=0;this.fear=this.mutations.bullied?0.3:0;
    const fleeRadius=100+(1-this.bravery)*50,fleeRadiusSq=fleeRadius*fleeRadius;
    let inShelter=false;for(let i=0;i<shelters.length;i++){const s=shelters[i];const dx=s.position.x-px,dy=s.position.y-py;if(dx*dx+dy*dy<s.radius*s.radius){inShelter=true;this.fear=this.mutations.bullied?0.2:0;break}}
    if(!inShelter){for(let i=0;i<predators.length;i++){const pred=predators[i];const dx=px-pred.position.x,dy=py-pred.position.y,dsq=dx*dx+dy*dy;if(dsq<fleeRadiusSq){const d=Math.sqrt(dsq),inv=1/(d+0.001);fleeX+=dx*inv;fleeY+=dy*inv;this.fear=Math.max(this.fear,1-d/fleeRadius)}}}
    if(fleeX!==0||fleeY!==0){let fm=Math.sqrt(fleeX*fleeX+fleeY*fleeY);if(fm>0){fleeX/=fm;fleeY/=fm}const fs=MAX_SPEED*(1.5+this.bravery*0.3);fleeX=fleeX*fs-vx;fleeY=fleeY*fs-vy;fm=Math.sqrt(fleeX*fleeX+fleeY*fleeY);const fl=MAX_FORCE*3;if(fm>fl){fleeX=fleeX/fm*fl;fleeY=fleeY/fm*fl}const fleeMult=(this.fear>0.3?4:1)*(4-this.bravery);ax+=fleeX*fleeMult;ay+=fleeY*fleeMult}

    // Avoid obstacles - inline optimized
    let obsX=0,obsY=0;const obsAvoidRadiusSq=this.fear>0.3?6400:2500;
    for(let i=0;i<obstacles.length;i++){const o=obstacles[i];const dx=px-o.x,dy=py-o.y,dsq=dx*dx+dy*dy;if(dsq<obsAvoidRadiusSq){const inv=1/(dsq+0.001);obsX+=dx*inv;obsY+=dy*inv}}
    if(obsX!==0||obsY!==0){let om=Math.sqrt(obsX*obsX+obsY*obsY);if(om>0){obsX/=om;obsY/=om}const os=MAX_SPEED*(this.fear>0.3?1.5:1);obsX=obsX*os-vx;obsY=obsY*os-vy;om=Math.sqrt(obsX*obsX+obsY*obsY);const ol=MAX_FORCE*(this.fear>0.3?3:2);if(om>ol){obsX=obsX/om*ol;obsY=obsY/om*ol}ax+=obsX*(this.fear>0.3?3:1);ay+=obsY*(this.fear>0.3?3:1)}

    // Danger zones - inline
    let dangerX=0,dangerY=0;for(let i=0;i<dangerZones.length;i++){const z=dangerZones[i];const dx=px-z.position.x,dy=py-z.position.y,dsq=dx*dx+dy*dy;if(dsq<z.radius*z.radius){dangerX+=dx*z.intensity;dangerY+=dy*z.intensity}}
    if(dangerX!==0||dangerY!==0){let dm=Math.sqrt(dangerX*dangerX+dangerY*dangerY);if(dm>0){dangerX/=dm;dangerY/=dm}dangerX=dangerX*MAX_SPEED*0.5-vx;dangerY=dangerY*MAX_SPEED*0.5-vy;dm=Math.sqrt(dangerX*dangerX+dangerY*dangerY);if(dm>MAX_FORCE){dangerX=dangerX/dm*MAX_FORCE;dangerY=dangerY/dm*MAX_FORCE}ax+=dangerX*1.5;ay+=dangerY*1.5}

    // Shelter seeking - inline
    if(this.fear>0.3){let closest=null,closestDist=Infinity;for(let i=0;i<shelters.length;i++){const s=shelters[i];if(s.occupants>=s.capacity)continue;const dx=s.position.x-px,dy=s.position.y-py,d=dx*dx+dy*dy;if(d<closestDist){closestDist=d;closest=s}}if(closest&&closestDist<40000){let sx=closest.position.x-px,sy=closest.position.y-py,sm=Math.sqrt(sx*sx+sy*sy);if(sm>0){sx/=sm;sy/=sm}sx=sx*MAX_SPEED-vx;sy=sy*MAX_SPEED-vy;sm=Math.sqrt(sx*sx+sy*sy);const sl=MAX_FORCE*2;if(sm>sl){sx=sx/sm*sl;sy=sy/sm*sl}ax+=sx*2;ay+=sy*2}}

    // Perching
    if(!this.mutations.flightless){const threshold=60+this.laziness*30;if(this.fatigue>=threshold&&dayPhase<=0.5){let closest=null,closestDist=Infinity;for(let i=0;i<perches.length;i++){const spot=perches[i].getRestSpot();if(!spot)continue;const dx=spot.x-px,dy=spot.y-py,d=dx*dx+dy*dy;if(d<closestDist){closestDist=d;closest={perch:perches[i],spot}}}if(closest&&closestDist<32400){this.perchTarget=closest;if(closestDist<100){this.isPerching=true;this.position.set(closest.spot.x,closest.spot.y);this.velocity.zero();closest.perch.occupants.push(this)}else{let pcx=closest.spot.x-px,pcy=closest.spot.y-py,pcm=Math.sqrt(pcx*pcx+pcy*pcy);if(pcm>0){pcx/=pcm;pcy/=pcm}pcx=pcx*MAX_SPEED*0.6-vx;pcy=pcy*MAX_SPEED*0.6-vy;pcm=Math.sqrt(pcx*pcx+pcy*pcy);if(pcm>MAX_FORCE){pcx=pcx/pcm*MAX_FORCE;pcy=pcy/pcm*MAX_FORCE}ax+=pcx*1.5;ay+=pcy*1.5}}}}

    // Pond seeking
    if(pond&&this.energy<this.maxEnergy*0.15&&this.fear<0.3){const dx=pond.position.x-px,dy=pond.position.y-py,d=dx*dx+dy*dy;if(d<6400){if(d<625&&pond.fish.length>0){this.isFishing=true;this.fishTimer=60;this.velocity.zero()}else{let pdx=dx,pdy=dy,pm=Math.sqrt(pdx*pdx+pdy*pdy);if(pm>0){pdx/=pm;pdy/=pm}pdx=pdx*MAX_SPEED*0.3-vx;pdy=pdy*MAX_SPEED*0.3-vy;pm=Math.sqrt(pdx*pdx+pdy*pdy);const pl=MAX_FORCE*0.5;if(pm>pl){pdx=pdx/pm*pl;pdy=pdy/pm*pl}ax+=pdx*3;ay+=pdy*3}}}

    // Cursor - only if vortexBoids is enabled
    if(cursorPos&&cursorMode!=='none'&&settingsRef.current.vortexBoids){const cdx=cursorPos.x-px,cdy=cursorPos.y-py,cdsq=cdx*cdx+cdy*cdy;if(cdsq<10000){const cd=Math.sqrt(cdsq);let ccx=cursorMode==='attract'?cdx:-cdx,ccy=cursorMode==='attract'?cdy:-cdy,ccm=Math.sqrt(ccx*ccx+ccy*ccy);if(ccm>0){ccx/=ccm;ccy/=ccm}ccx=ccx*MAX_SPEED-vx;ccy=ccy*MAX_SPEED-vy;ccm=Math.sqrt(ccx*ccx+ccy*ccy);const cl=MAX_FORCE*2*cursorStrength;if(ccm>cl){ccx=ccx/ccm*cl;ccy=ccy/ccm*cl}const cf=1-cd/100;ax+=ccx*cf;ay+=ccy*cf}}

    this.acceleration.x+=ax;this.acceleration.y+=ay;
  }
  update(w,h,dayPhase,shelters,pond,predators,obstacles){
    this.age++;if(this.age>this.maxAge)return{alive:false,causeOfDeath:'age'};
    if(this.isFishing){this.fishTimer--;if(this.fishTimer<=0){this.isFishing=false;if(pond){const result=pond.tryFish(this);if(result.drowned)return{alive:false,causeOfDeath:'drowned'};if(result.caught)this.energy=Math.min(this.maxEnergy,this.energy+result.food)}}return{alive:true}}
    if(this.isPerching){this.fatigue=Math.max(0,this.fatigue-0.8);this.energy-=0.003*this.energyDrain;if((dayPhase>0.5&&this.fatigue<20)||this.fear>0.5){if(this.perchTarget){const idx=this.perchTarget.perch.occupants.indexOf(this);if(idx>-1)this.perchTarget.perch.occupants.splice(idx,1)}this.isPerching=false;this.perchTarget=null;const a=Math.random()*Math.PI*2;this.velocity.set(Math.cos(a)*2,Math.sin(a)*2)}return{alive:this.energy>0,causeOfDeath:'starved'}}
    if(this.isCollapsed){this.collapseTimer--;if(this.collapseTimer<=0){this.isCollapsed=false;this.fatigue=50}this.energy-=0.01*this.energyDrain;return{alive:this.energy>0,causeOfDeath:'starved'}}
    this.trail.push(new Vector2(this.position.x,this.position.y));if(this.trail.length>6)this.trail.shift();
    const px=this.position.x,py=this.position.y;
    for(let i=0;i<shelters.length;i++){const s=shelters[i];const dx=s.position.x-px,dy=s.position.y-py;if(dx*dx+dy*dy<s.radius*s.radius)s.occupants=Math.min(s.capacity,s.occupants+0.01)}
    this.energy-=(0.012+this.hunger*0.005)*this.energyDrain;this.fatigue+=(0.025-this.laziness*0.01)*(this.fatigueResistance||1);
    if(this.fear>0){this.energy-=0.04*this.energyDrain;this.fatigue+=0.04*(this.fatigueResistance||1)}
    if(this.isNocturnal&&dayPhase<0.4){this.energy+=0.005;this.fatigue-=0.01}
    if(this.friend){const fx=this.friend.position.x-px,fy=this.friend.position.y-py,dsq=fx*fx+fy*fy;if(dsq<2500){this.friendBond=Math.min(1,this.friendBond+0.001);this.fatigue-=0.005*this.friendBond}else if(dsq>40000){this.friendBond-=0.01;if(this.friendBond<=0)this.friend=null}}
    if(this.matingDisplay>0)this.matingDisplay-=0.02;
    const ageSlow=Math.max(0.5,1-(this.age/this.maxAge)*0.5);const speedMult=(0.6+dayPhase*0.4)*ageSlow*(this.speedMultiplier||1);const nocturnalBonus=(this.isNocturnal&&dayPhase<0.4)?1.3:1;
    const currentMaxSpeed=MAX_SPEED*speedMult*(1+this.fear*0.5)*nocturnalBonus;
    // Collision with obstacles - inline
    for(let i=0;i<obstacles.length;i++){const o=obstacles[i];const dx=px-o.x,dy=py-o.y,dsq=dx*dx+dy*dy;if(dsq<400){const m=Math.sqrt(dsq);if(m>0){this.acceleration.x+=dx/m*MAX_FORCE*4;this.acceleration.y+=dy/m*MAX_FORCE*4}}}
    this.velocity.addM(this.acceleration).limitM(currentMaxSpeed);this.position.addM(this.velocity);this.acceleration.zero();this.edges(w,h,predators);
    if(this.energy<=0)return{alive:false,causeOfDeath:'starved'};
    if(this.shouldDie)return{alive:false,causeOfDeath:'eaten'};
    return{alive:true}
  }
  canReproduce(nests,nearbyBoids,birthMult=1){
    if(this.energy<75||this.age<400||this.fatigue>40)return{can:false};
    let mate=null,isCrossBreed=false;for(const other of nearbyBoids){if(other===this||other.isCollapsed||other.isPerching||other.energy<60||other.age<400)continue;if(this.position.distSq(other.position)<625){mate=other;isCrossBreed=other.species!==this.species;break}}
    if(!mate)return{can:false};
    let nearNest=false;for(const n of nests)if((n.species===this.species||n.species===mate.species)&&this.position.distSq(n.position)<1225){nearNest=true;n.births++;break}
    const baseChance=(nearNest?0.004:0.001)*birthMult;const fertilityMult=this.fertilityBonus*(mate.fertilityBonus||1);
    if(Math.random()<(isCrossBreed?baseChance*0.3:baseChance)*fertilityMult)return{can:true,mate,isCrossBreed};return{can:false}
  }
  draw(ctx,showTrails,dayPhase,worldWidth,isFavorite){
    let displayHue=this.hue;if(this.isRainbow)displayHue=(this.hue+this.age*0.5)%360;if(this.mutations.mechanical)displayHue=200;const sm=this.sizeMultiplier||1;
    if(this.isFishing){ctx.fillStyle='rgba(100,150,255,0.5)';ctx.beginPath();ctx.arc(this.position.x,this.position.y,10,0,Math.PI*2);ctx.fill();ctx.fillStyle=`hsla(${displayHue},60%,50%,0.8)`;ctx.beginPath();ctx.arc(this.position.x,this.position.y-5,4*sm,0,Math.PI*2);ctx.fill();return}
    if(this.isCollapsed){ctx.fillStyle=`hsla(${displayHue},40%,30%,0.7)`;ctx.beginPath();ctx.ellipse(this.position.x,this.position.y,6*sm,3*sm,0,0,Math.PI*2);ctx.fill();return}
    if(this.isPerching){ctx.fillStyle=`hsla(${displayHue},60%,${30+dayPhase*20}%,0.9)`;ctx.beginPath();ctx.arc(this.position.x,this.position.y-3,5*sm,0,Math.PI*2);ctx.fill();return}
    if(isFavorite){ctx.strokeStyle='rgba(255,215,0,0.8)';ctx.lineWidth=3;ctx.beginPath();ctx.arc(this.position.x,this.position.y,18,0,Math.PI*2);ctx.stroke();ctx.fillStyle='rgba(255,215,0,0.3)';ctx.fill()}
    if(showTrails&&this.trail.length>1){ctx.beginPath();ctx.moveTo(this.trail[0].x,this.trail[0].y);for(let i=1;i<this.trail.length;i++)ctx.lineTo(this.trail[i].x,this.trail[i].y);ctx.lineTo(this.position.x,this.position.y);ctx.strokeStyle=`hsla(${displayHue},70%,50%,0.4)`;ctx.lineWidth=2;ctx.stroke()}
    const angle=Math.atan2(this.velocity.y,this.velocity.x);const ageSize=Math.max(0.7,1-(this.age/this.maxAge)*0.3);const size=(6+(this.energy/this.maxEnergy)*2)*ageSize*sm;
    ctx.save();ctx.translate(this.position.x,this.position.y);
    if(this.isGlowing){const gp=0.5+Math.sin(this.age*0.05)*0.3;const g=ctx.createRadialGradient(0,0,0,0,0,size*2.5);g.addColorStop(0,this.mutations.mechanical?`rgba(150,200,255,${gp*0.5})`:`hsla(${displayHue},80%,70%,${gp*0.5})`);g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(0,0,size*2.5,0,Math.PI*2);ctx.fill()}
    if(this.friend&&this.friendBond>0.3){const dx=this.friend.position.x-this.position.x,dy=this.friend.position.y-this.position.y;if(dx*dx+dy*dy<worldWidth*worldWidth*0.16){ctx.strokeStyle=`rgba(255,200,255,${this.friendBond*0.5})`;ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(dx,dy);ctx.stroke()}}
    ctx.rotate(angle);
    if(this.fear>0){ctx.fillStyle=`rgba(255,200,100,${this.fear*0.3})`;ctx.beginPath();ctx.arc(0,0,12,0,Math.PI*2);ctx.fill()}
    const mutCount=this.getMutationCount();if(mutCount>0){ctx.strokeStyle=`rgba(200,100,255,${0.4+Math.sin(this.age*0.03)*0.2})`;ctx.lineWidth=1.5;ctx.beginPath();ctx.arc(0,0,size+3,0,Math.PI*2);ctx.stroke()}
    if(this.hasArmor){ctx.strokeStyle='rgba(150,150,200,0.6)';ctx.lineWidth=2;ctx.beginPath();ctx.arc(0,0,size*0.8,-Math.PI*0.7,Math.PI*0.7);ctx.stroke()}
    const ageGray=(this.age/this.maxAge)*30;const fatigueDim=Math.max(0.5,1-this.fatigue/150);const lightness=((40+dayPhase*20)+this.fear*20-ageGray)*fatigueDim;const baseAlpha=this.hasCamouflage?0.5:1;
    let bodyColor;if(this.mutations.mechanical)bodyColor=`rgba(120,140,160,${baseAlpha})`;else if(this.mutations.paper)bodyColor=`rgba(240,240,230,${baseAlpha})`;else bodyColor=`hsla(${displayHue},${70-ageGray}%,${Math.max(20,lightness)}%,${baseAlpha})`;
    ctx.fillStyle=bodyColor;ctx.beginPath();ctx.moveTo(size,0);ctx.lineTo(-size*0.6,-size*0.5);ctx.lineTo(-size*0.6,size*0.5);ctx.closePath();ctx.fill();
    ctx.fillStyle=`rgba(255,255,255,${(0.5+dayPhase*0.3)*fatigueDim})`;ctx.beginPath();ctx.arc(0,0,1.5,0,Math.PI*2);ctx.fill();ctx.restore()
  }
}

const mutationInfo={
  // Good mutations
  giant:{emoji:'ü¶£',name:'Giant',desc:'1.5x size, slower',color:'#a855f7',type:'good'},
  tiny:{emoji:'üêú',name:'Tiny',desc:'0.6x size, faster',color:'#22d3ee',type:'good'},
  speedy:{emoji:'‚ö°',name:'Speedy',desc:'1.4x speed',color:'#facc15',type:'good'},
  glowing:{emoji:'‚ú®',name:'Glowing',desc:'Bioluminescent',color:'#4ade80',type:'good'},
  tough:{emoji:'üí™',name:'Tough',desc:'50% fatigue resist',color:'#f97316',type:'good'},
  longlived:{emoji:'üïê',name:'Long-lived',desc:'1.5x lifespan',color:'#a78bfa',type:'good'},
  fertile:{emoji:'ü•ö',name:'Fertile',desc:'2x reproduction',color:'#fb7185',type:'good'},
  camouflage:{emoji:'üëª',name:'Camouflage',desc:'Harder to catch',color:'#94a3b8',type:'good'},
  plated:{emoji:'üõ°Ô∏è',name:'Plated',desc:'Survives 1 attack',color:'#60a5fa',type:'good'},
  nocturnal:{emoji:'ü¶â',name:'Nocturnal',desc:'Night boost',color:'#6366f1',type:'good'},
  rainbow:{emoji:'üåà',name:'Rainbow',desc:'Color shifts',color:'#ec4899',type:'good'},
  zen:{emoji:'üßò',name:'Zen',desc:'+40% bravery',color:'#2dd4bf',type:'good'},
  magnetic:{emoji:'üß≤',name:'Magnetic',desc:'+50% sociability',color:'#f472b6',type:'good'},
  bigstomach:{emoji:'üéà',name:'Big Stomach',desc:'2x food capacity',color:'#34d399',type:'good'},
  mechanical:{emoji:'ü§ñ',name:'Mechanical',desc:'1.1x speed, low fatigue',color:'#38bdf8',type:'good'},
  // NEW good mutations
  fighter:{emoji:'‚öîÔ∏è',name:'Fighter',desc:'50% to fight off predator',color:'#ef4444',type:'good'},
  swift:{emoji:'ü¶Ö',name:'Swift',desc:'Faster turns, agile',color:'#06b6d4',type:'good'},
  healer:{emoji:'üíö',name:'Healer',desc:'Slowly regenerates energy',color:'#22c55e',type:'good'},
  lucky:{emoji:'üçÄ',name:'Lucky',desc:'Better survival odds',color:'#84cc16',type:'good'},
  scout:{emoji:'üëÅÔ∏è',name:'Scout',desc:'Sees predators from far',color:'#8b5cf6',type:'good'},
  leader:{emoji:'üëë',name:'Leader',desc:'Nearby boids get +speed',color:'#fbbf24',type:'good'},
  chonky:{emoji:'ü¶õ',name:'Chonky',desc:'Harder to catch, slower',color:'#d97706',type:'good'},
  photosynthetic:{emoji:'üå±',name:'Photosynthetic',desc:'Gains energy in daylight',color:'#16a34a',type:'good'},
  electric:{emoji:'‚ö°',name:'Electric',desc:'Shocks nearby predators',color:'#eab308',type:'good'},
  silent:{emoji:'ü§´',name:'Silent',desc:'Harder for predators to detect',color:'#64748b',type:'good'},
  wings:{emoji:'ü™Ω',name:'Wings',desc:'1.3x speed, low fatigue',color:'#a5b4fc',type:'good'},
  stubborn:{emoji:'ü¶¥',name:'Stubborn',desc:'Never collapses from fatigue',color:'#78716c',type:'good'},
  wise:{emoji:'üß†',name:'Wise',desc:'Better at avoiding danger',color:'#c084fc',type:'good'},
  fluffy:{emoji:'üêë',name:'Fluffy',desc:'Slower energy drain',color:'#fef3c7',type:'good'},
  acrobat:{emoji:'ü§∏',name:'Acrobat',desc:'Dodges attacks easier',color:'#f0abfc',type:'good'},
  // Neutral mutations
  aggressive:{emoji:'üò†',name:'Aggressive',desc:'Hunts cannibals',color:'#ef4444',type:'neutral'},
  ravenous:{emoji:'üçñ',name:'Ravenous',desc:'Eats fast, needs more',color:'#84cc16',type:'neutral'},
  immortal:{emoji:'‚ôæÔ∏è',name:'Immortal',desc:'No age death, 3x hunger',color:'#fbbf24',type:'neutral'},
  smallstomach:{emoji:'ü´ò',name:'Small Stomach',desc:'0.5x capacity, 0.66x drain',color:'#fb923c',type:'neutral'},
  berserker:{emoji:'üî•',name:'Berserker',desc:'Fast when low health',color:'#dc2626',type:'neutral'},
  hermit:{emoji:'üèîÔ∏è',name:'Hermit',desc:'Avoids others, low fatigue',color:'#737373',type:'neutral'},
  vampire:{emoji:'üßõ',name:'Vampire',desc:'Drains energy from others',color:'#7c2d12',type:'neutral'},
  // Bad mutations
  cannibal:{emoji:'ü¶∑',name:'Cannibal',desc:'Eats birds when <20% food',color:'#dc2626',type:'bad'},
  traitor:{emoji:'üíÄ',name:'Traitor',desc:'Becomes predator on death',color:'#7c3aed',type:'bad'},
  fat:{emoji:'üê∑',name:'Fat',desc:'1.3x size, 0.7x speed',color:'#fca5a5',type:'bad'},
  paper:{emoji:'üìÑ',name:'Paper',desc:'2x fatigue, very fragile',color:'#e5e7eb',type:'bad'},
  flightless:{emoji:'üêß',name:'Flightless',desc:'0.5x speed, no perching',color:'#6b7280',type:'bad'},
  tasty:{emoji:'üçó',name:'Tasty',desc:'Predators prioritize you',color:'#f87171',type:'bad'},
  bullied:{emoji:'üò¢',name:'Bullied',desc:'-40% social, always scared',color:'#a1a1aa',type:'bad'},
  clumsy:{emoji:'ü§ï',name:'Clumsy',desc:'Bumps into things more',color:'#fda4af',type:'bad'},
  loud:{emoji:'üì¢',name:'Loud',desc:'Predators hear you easier',color:'#f97316',type:'bad'},
  sleepy:{emoji:'üò¥',name:'Sleepy',desc:'Gets tired faster',color:'#a3a3a3',type:'bad'},
  fragile:{emoji:'ü•Ä',name:'Fragile',desc:'Dies easier, shorter life',color:'#be185d',type:'bad'},
  cursed:{emoji:'üëÅÔ∏è‚Äçüó®Ô∏è',name:'Cursed',desc:'Bad luck, attracts danger',color:'#4c1d95',type:'bad'},
  // Special mutations
  egggiver:{emoji:'ü•ö',name:'Egg-Giver',desc:'Dies, spawns 3 mutant babies',color:'#f0abfc',type:'special'},
  phoenix:{emoji:'üî•',name:'Phoenix',desc:'Reborn once on death',color:'#f97316',type:'special'},
  mimic:{emoji:'üé≠',name:'Mimic',desc:'Copies nearby mutations',color:'#8b5cf6',type:'special'}
};

function App(){
  const canvasRef=useRef(null);
  const stateRef=useRef({boids:[],obstacles:[],predators:[],food:[],trees:[],shelters:[],nests:[],dangerZones:[],ripples:[],bugs:[],corpses:[],pond:null,time:0,dayTime:0,seasonTime:0,cursorPos:null,nextPackId:0,width:900,height:450,spatialHash:new SpatialHash(50)});
  const settingsRef=useRef({popCap:150,gameSpeed:1,mutationMult:1,birthMult:1,bugMult:1,predBreeding:true,cursorStrength:1,startBoids:60,vortexBoids:true,vortexPredators:false});
  const animRef=useRef(null);
  const[tool,setTool]=useState('food');const[showTrails,setShowTrails]=useState(false);const[cursorMode,setCursorMode]=useState('none');
  const[stats,setStats]=useState({boids:0,day:true,season:'Spring',mutants:0,multiMutants:0,maxMutations:0,predators:0,bugs:0,fps:60});
  const[mutationLog,setMutationLog]=useState([]);const[rosterData,setRosterData]=useState([]);
  const[selectedBoid,setSelectedBoid]=useState(null);const[showMutationPanel,setShowMutationPanel]=useState(false);
  const[favoriteBoid,setFavoriteBoid]=useState(null);const[paused,setPaused]=useState(false);
  const[canvasSize,setCanvasSize]=useState({w:900,h:450});
  const[selectedPredator,setSelectedPredator]=useState(null);const[showPredMutPanel,setShowPredMutPanel]=useState(false);
  const[predatorRoster,setPredatorRoster]=useState([]);const[showDNALab,setShowDNALab]=useState(false);
  const[vortexBoids,setVortexBoids]=useState(true);const[vortexPredators,setVortexPredators]=useState(false);
  const[showRoster,setShowRoster]=useState(true);const[showLog,setShowLog]=useState(true);
  const[expandRoster,setExpandRoster]=useState(false);const[expandLog,setExpandLog]=useState(false);const[expandLegend,setExpandLegend]=useState(true);
  
  const pausedRef=useRef(false);const showTrailsRef=useRef(false);const cursorModeRef=useRef('none');const favoriteRef=useRef(null);
  const mutationLogRef=useRef([]);const lastFrameTime=useRef(performance.now());const fpsRef=useRef(60);
  
  useEffect(()=>{pausedRef.current=paused},[paused]);
  useEffect(()=>{showTrailsRef.current=showTrails},[showTrails]);
  useEffect(()=>{cursorModeRef.current=cursorMode},[cursorMode]);
  useEffect(()=>{favoriteRef.current=favoriteBoid},[favoriteBoid]);
  
  const addRipple=useCallback((x,y,color,size)=>{stateRef.current.ripples.push(new Ripple(x,y,color,size))},[]);
  const addMutationLog=useCallback((type,event,boidSpecies,isHybrid)=>{const info=mutationInfo[type];if(!info)return;const speciesName=isHybrid?'Hybrid':(boidSpecies===0?'Cyan':'Gold');const logEntry={id:Date.now()+Math.random(),timestamp:new Date().toLocaleTimeString(),type,info,speciesName,event};mutationLogRef.current=[logEntry,...mutationLogRef.current];setMutationLog([...mutationLogRef.current])},[]);
  const addDangerZone=useCallback((x,y)=>{const state=stateRef.current;for(const z of state.dangerZones)if(z.position.distSq(new Vector2(x,y))<1600)return;state.dangerZones.push(new DangerZone(x,y))},[]);
  
  const initWorld=useCallback((w,h)=>{
    const state=stateRef.current;const settings=settingsRef.current;
    state.width=w;state.height=h;
    const numS0=Math.floor(settings.startBoids*0.55),numS1=settings.startBoids-numS0;
    const s0=Array.from({length:numS0},()=>new Boid(Math.random()*w,Math.random()*(h-120),0,null,false,null,settings.mutationMult));
    const s1=Array.from({length:numS1},()=>new Boid(Math.random()*w,Math.random()*(h-120),1,null,false,null,settings.mutationMult));
    state.boids=[...s0,...s1];
    for(const b of state.boids)if(Math.random()<0.3){const cands=state.boids.filter(o=>o!==b&&o.species===b.species&&!o.friend);if(cands.length>0){const f=cands[Math.floor(Math.random()*cands.length)];b.friend=f;f.friend=b;b.friendBond=0.5;f.friendBond=0.5}}
    state.obstacles=[];state.predators=[];state.food=[];state.dangerZones=[];state.ripples=[];state.bugs=[];state.corpses=[];state.dayTime=0;state.seasonTime=0;state.nextPackId=0;
    state.trees=[new Tree(w*0.1,h-30),new Tree(w*0.3,h-35),new Tree(w*0.5,h-30),new Tree(w*0.7,h-40),new Tree(w*0.9,h-30)];
    state.shelters=[new Shelter(80,h-100),new Shelter(w-80,h-100)];
    state.nests=[new Nest(w*0.22,h-130,0),new Nest(w*0.78,h-130,1)];
    state.pond=new Pond(w*0.5,h-80,100,50);
  },[]);
  
  const giveMutation=useCallback((boidId,mutationType)=>{
    const state=stateRef.current;const boid=state.boids.find(b=>b.id===boidId);if(!boid)return;
    boid.mutations[mutationType]=true;boid.applyMutationEffects();addMutationLog(mutationType,'given',boid.species,boid.isHybrid);addRipple(boid.position.x,boid.position.y,'rgb(255,200,0)',30);
  },[addMutationLog,addRipple]);

  const givePredatorMutation=useCallback((predId,mutationType)=>{
    const state=stateRef.current;const pred=state.predators.find(p=>p.id===predId);if(!pred)return;
    pred.mutations[mutationType]=true;pred.applyMutationEffects();addMutationLog(mutationType,'given_pred','Predator',false);addRipple(pred.position.x,pred.position.y,'rgb(255,100,50)',30);
  },[addMutationLog,addRipple]);

  useEffect(()=>{settingsRef.current.vortexBoids=vortexBoids},[vortexBoids]);
  useEffect(()=>{settingsRef.current.vortexPredators=vortexPredators},[vortexPredators]);
  
  useEffect(()=>{
    const canvas=canvasRef.current;const ctx=canvas.getContext('2d');
    initWorld(canvas.width,canvas.height);
    const animate=()=>{
      const now=performance.now();const delta=now-lastFrameTime.current;lastFrameTime.current=now;
      fpsRef.current=fpsRef.current*0.9+(1000/delta)*0.1;
      
      const state=stateRef.current;const settings=settingsRef.current;
      const w=state.width,h=state.height;
      
      if(!pausedRef.current){
        const spd=Math.max(1,Math.floor(settings.gameSpeed));
        for(let tick=0;tick<spd;tick++){
          state.time+=16;state.dayTime+=0.0015;const dayPhase=(Math.sin(state.dayTime)+1)/2;const isDay=dayPhase>0.45;state.seasonTime+=0.0002;const season=state.seasonTime%1;const seasonNames=['Spring','Summer','Fall','Winter'];const seasonIndex=Math.floor(season*4);
          
          // Rebuild spatial hash
          state.spatialHash.clear();
          for(const b of state.boids)state.spatialHash.insert(b);
          for(const p of state.predators)state.spatialHash.insert(p);
          
          const baseBugRate=seasonIndex===1?0.15:seasonIndex===3?0.03:0.08;const maxBugs=Math.floor((seasonIndex===1?60:seasonIndex===3?20:40)*settings.bugMult);
          if(Math.random()<baseBugRate*settings.bugMult&&state.bugs.length<maxBugs){const tree=state.trees[Math.floor(Math.random()*state.trees.length)];state.bugs.push(tree.spawnBug())}
          state.bugs=state.bugs.filter(b=>b.update(w,h,state.obstacles));
          if(state.pond)state.pond.update();
          
          const foodChance=seasonIndex===1?0.003:seasonIndex===3?0.0003:0.0015;
          if(isDay&&Math.random()<foodChance&&state.food.length<5){const fx=50+Math.random()*(w-100),fy=50+Math.random()*(h-180);state.food.push(new FoodSource(fx,fy));addRipple(fx,fy,'rgb(100,255,150)',25)}
          state.food=state.food.filter(f=>f.amount>0);state.dangerZones=state.dangerZones.filter(z=>z.update());state.ripples=state.ripples.filter(r=>r.update());state.corpses=state.corpses.filter(c=>c.update());
          for(const s of state.shelters)s.occupants=0;
          
          const caughtBoids=new Set();const newPredatorsFromTraitors=[];
          for(const pred of state.predators){const caught=pred.hunt(state.boids,state.predators,state.shelters,dayPhase,state.spatialHash);if(caught){caughtBoids.add(caught);addRipple(caught.position.x,caught.position.y,'rgb(255,100,100)',45);addDangerZone(caught.position.x,caught.position.y);state.corpses.push(new Corpse(caught.position.x,caught.position.y,caught.species));if(caught.mutations.traitor){newPredatorsFromTraitors.push(new Predator(caught.position.x,caught.position.y,state.nextPackId++,0,{...caught.mutations}));addRipple(caught.position.x,caught.position.y,'rgb(128,0,255)',50)}}}
          for(const boid of state.boids){
            if(boid.armorJustBroke){boid.armorJustBroke=false;addMutationLog('plated','armor_broke',boid.species,boid.isHybrid);addRipple(boid.position.x,boid.position.y,'rgb(100,150,255)',35)}
            if(boid.justFoughtOff){boid.justFoughtOff=false;addRipple(boid.position.x,boid.position.y,'rgb(255,100,50)',30)}
            if(boid.justKilledPredator){boid.justKilledPredator=false;addMutationLog('fighter','killed_pred',boid.species,boid.isHybrid);addRipple(boid.position.x,boid.position.y,'rgb(255,0,0)',60)}
            if(boid.justEvolvedFighter){boid.justEvolvedFighter=false;addMutationLog('fighter','evolved',boid.species,boid.isHybrid);addRipple(boid.position.x,boid.position.y,'rgb(255,200,0)',45)}
            boid.nearDeathTriggered=false;
            // Healer regeneration
            if(boid.mutations.healer)boid.energy=Math.min(boid.maxEnergy,boid.energy+0.02);
            // Photosynthetic - gains energy in daylight
            if(boid.mutations.photosynthetic&&dayPhase>0.5)boid.energy=Math.min(boid.maxEnergy,boid.energy+0.03);
            // Berserker - faster when low health
            if(boid.mutations.berserker&&boid.energy<boid.maxEnergy*0.3)boid.speedMultiplier=(boid.speedMultiplier||1)*1.4;
          }
          state.boids=state.boids.filter(b=>!caughtBoids.has(b));state.predators.push(...newPredatorsFromTraitors);
          
          const newPredators=[];
          state.predators=state.predators.filter(p=>{
            if(p.killedByFighter){addRipple(p.position.x,p.position.y,'rgb(255,50,50)',50);return false}
            const alive=p.update(w,h,state.obstacles,state.cursorPos,cursorModeRef.current,settings.cursorStrength,settings.vortexPredators);if(!alive)addRipple(p.position.x,p.position.y,'rgb(100,100,100)',35);if(settings.predBreeding&&alive&&p.energy>130&&p.kills>=3&&Math.random()<0.01){p.energy-=50;const child=new Predator(p.position.x+(Math.random()-0.5)*30,p.position.y+(Math.random()-0.5)*30,p.packId,p.generation+1,{...p.mutations});newPredators.push(child);addRipple(p.position.x,p.position.y,'rgb(255,150,50)',40)}return alive});
          state.predators.push(...newPredators);
          
          const perches=state.trees.map(t=>t.perch);
          const cannibalVictims=new Set();
          
          for(const boid of state.boids){
            // Cannibal check
            if(boid.mutations.cannibal&&boid.energy<boid.maxEnergy*0.2){
              const nearby=state.spatialHash.getNearby(boid.position.x,boid.position.y,1);
              for(const other of nearby){if(other instanceof Boid&&other!==boid&&!other.isCollapsed&&boid.position.distSq(other.position)<225){boid.energy=Math.min(boid.maxEnergy,boid.energy+30);cannibalVictims.add(other);addRipple(other.position.x,other.position.y,'rgb(200,50,50)',30);break}}}
            // Bug eating
            for(const bug of state.bugs)if(boid.position.distSq(bug.position)<144){bug.energy=0;boid.energy=Math.min(boid.maxEnergy,boid.energy+8);boid.fatigue=Math.max(0,boid.fatigue-2)}
            // Corpse eating
            for(const c of state.corpses)if(boid.position.distSq(c.position)<225&&c.nutrition>0){c.nutrition-=0.5;boid.energy=Math.min(boid.maxEnergy,boid.energy+0.3)}
            // Food attraction
            for(const f of state.food){if(f.amount<=0||boid.isPerching||boid.isCollapsed||boid.fear>0.3)continue;const dsq=boid.position.distSq(f.position);const hm=0.5+boid.hunger;if(dsq<4900*hm*hm){if(dsq<144){f.amount-=0.4;const foodGain=boid.mutations.bigstomach?2:boid.mutations.smallstomach?0.5:1;boid.energy=Math.min(boid.maxEnergy,boid.energy+foodGain);boid.fatigue=Math.max(0,boid.fatigue-0.3)}else{const attract=f.position.sub(boid.position).normalize().mult(MAX_SPEED*0.4*hm).sub(boid.velocity).limit(MAX_FORCE);boid.acceleration=boid.acceleration.add(attract)}}}
            const nearbyBoids=state.spatialHash.getNearby(boid.position.x,boid.position.y,2).filter(b=>b instanceof Boid);
            boid.flock(nearbyBoids,state.obstacles,state.predators,state.dangerZones,state.shelters,perches,dayPhase,state.cursorPos,cursorModeRef.current,state.pond,settings.cursorStrength)
          }
          state.boids=state.boids.filter(b=>!cannibalVictims.has(b));
          
          const newBoids=[];const eggBabies=[];
          state.boids=state.boids.filter(boid=>{
            const result=boid.update(w,h,dayPhase,state.shelters,state.pond,state.predators,state.obstacles);
            if(!result.alive){
              addRipple(boid.position.x,boid.position.y,'rgb(150,150,150)',20);
              if(result.causeOfDeath==='drowned')addRipple(boid.position.x,boid.position.y,'rgb(50,100,200)',40);
              state.corpses.push(new Corpse(boid.position.x,boid.position.y,boid.species));
              if(boid.friend)boid.friend.friend=null;
              if(boid.perchTarget){const idx=boid.perchTarget.perch.occupants.indexOf(boid);if(idx>-1)boid.perchTarget.perch.occupants.splice(idx,1)}
              if(boid.mutations.traitor&&result.causeOfDeath!=='drowned'){state.predators.push(new Predator(boid.position.x,boid.position.y,state.nextPackId++,0,{}));addRipple(boid.position.x,boid.position.y,'rgb(128,0,255)',50)}
              if(boid.mutations.egggiver){for(let i=0;i<3;i++){const allMuts=Object.keys(mutationInfo).filter(m=>m!=='egggiver');const randomMut=allMuts[Math.floor(Math.random()*allMuts.length)];eggBabies.push(new Boid(boid.position.x+(Math.random()-0.5)*30,boid.position.y+(Math.random()-0.5)*30,boid.species,null,false,null,1,randomMut));addMutationLog(randomMut,'egg',boid.species,false)}addRipple(boid.position.x,boid.position.y,'rgb(255,200,255)',60)}
            }
            if(result.alive&&state.boids.length+newBoids.length<settings.popCap){
              const nearbyBoids=state.spatialHash.getNearby(boid.position.x,boid.position.y,1).filter(b=>b instanceof Boid);
              const reproResult=boid.canReproduce(state.nests,nearbyBoids,settings.birthMult);
              if(reproResult.can){
                boid.energy-=35;boid.matingDisplay=1;if(reproResult.mate){reproResult.mate.energy-=25;reproResult.mate.matingDisplay=0.8}
                let babySpecies,isHybrid=false;if(reproResult.isCrossBreed){isHybrid=true;babySpecies=Math.random()>0.5?boid.species:reproResult.mate.species}else babySpecies=boid.species;
                const combinedTraits=reproResult.mate?{bravery:(boid.bravery+reproResult.mate.bravery)/2,hunger:(boid.hunger+reproResult.mate.hunger)/2,laziness:(boid.laziness+reproResult.mate.laziness)/2,sociability:(boid.sociability+reproResult.mate.sociability)/2}:{bravery:boid.bravery,hunger:boid.hunger,laziness:boid.laziness,sociability:boid.sociability};
                const parentMutations={parent1Muts:boid.mutations||{},parent2Muts:reproResult.mate?(reproResult.mate.mutations||{}):{}};
                const baby=new Boid(boid.position.x+(Math.random()-0.5)*20,boid.position.y+(Math.random()-0.5)*20,babySpecies,combinedTraits,isHybrid,parentMutations,settings.mutationMult);
                for(const mutType of baby.getMutationList()){const p1Has=parentMutations.parent1Muts[mutType],p2Has=parentMutations.parent2Muts[mutType];if(p1Has&&p2Has)addMutationLog(mutType,'both',babySpecies,isHybrid);else if(p1Has||p2Has)addMutationLog(mutType,'inherited',babySpecies,isHybrid);else addMutationLog(mutType,'new',babySpecies,isHybrid)}
                newBoids.push(baby);
                let rippleColor;if(baby.getMutationCount()>0)rippleColor='rgb(255,100,255)';else if(isHybrid)rippleColor='rgb(150,255,150)';else rippleColor=`rgb(${boid.species===0?'100,200,255':'255,200,100'})`;
                addRipple(boid.position.x,boid.position.y,rippleColor,isHybrid||baby.getMutationCount()>0?40:30);
              }
            }
            return result.alive;
          });
          state.boids.push(...newBoids,...eggBabies);
          
          // Friendship forming
          if(state.time%1000<20){for(const boid of state.boids)if(!boid.friend&&boid.sociability>0.5){const cands=state.spatialHash.getNearby(boid.position.x,boid.position.y,1).filter(b=>b instanceof Boid&&b!==boid&&b.species===boid.species&&!b.friend);if(cands.length>0){const f=cands[0];boid.friend=f;f.friend=boid;boid.friendBond=0.3;f.friendBond=0.3;break}}}
          
          // Stats update (throttled)
          if(state.time%500<20){
            let mutants=0,multiMutants=0,maxMutations=0;const rosterArr=[];
            for(const b of state.boids){const count=b.getMutationCount();if(count>0){mutants++;rosterArr.push({id:b.id,species:b.species,isHybrid:b.isHybrid,energy:b.energy,maxEnergy:b.maxEnergy,age:b.age,maxAge:b.maxAge,hasArmor:b.hasArmor,mutations:b.getMutationList(),isFishing:b.isFishing,type:'boid'})}if(count>1)multiMutants++;if(count>maxMutations)maxMutations=count}
            rosterArr.sort((a,b)=>b.mutations.length-a.mutations.length);
            // Predator roster
            const predRoster=state.predators.map(p=>({id:p.id,energy:p.energy,generation:p.generation,kills:p.kills,isLeader:p.isLeader,mutations:p.getMutationList(),type:'predator'}));
            setStats({boids:state.boids.length,day:isDay,season:seasonNames[seasonIndex],mutants,multiMutants,maxMutations,predators:state.predators.length,bugs:state.bugs.length,fps:Math.round(fpsRef.current)});
            setRosterData(rosterArr);setPredatorRoster(predRoster);
          }
        }
      }
      
      // Render
      const dayPhase=(Math.sin(state.dayTime)+1)/2;const season=state.seasonTime%1;
      ctx.fillStyle=`rgba(${12+dayPhase*12},${12+dayPhase*18},${22+dayPhase*25},0.25)`;ctx.fillRect(0,0,w,h);
      for(const z of state.dangerZones)z.draw(ctx);for(const c of state.corpses)c.draw(ctx);
      if(state.pond)state.pond.draw(ctx,state.time);
      for(const f of state.food)f.draw(ctx,state.time,season);for(const b of state.bugs)b.draw(ctx);for(const s of state.shelters)s.draw(ctx,dayPhase);for(const n of state.nests)n.draw(ctx);
      for(const t of state.trees)t.draw(ctx,dayPhase);
      for(const o of state.obstacles){ctx.fillStyle='rgba(80,70,60,0.9)';ctx.beginPath();ctx.arc(o.x,o.y,14,0,Math.PI*2);ctx.fill()}
      for(const p of state.predators)p.draw(ctx,state.time,dayPhase);
      for(const b of state.boids)b.draw(ctx,showTrailsRef.current,dayPhase,w,b.id===favoriteRef.current);
      for(const r of state.ripples)r.draw(ctx);
      if(state.cursorPos&&cursorModeRef.current!=='none'){ctx.strokeStyle=cursorModeRef.current==='attract'?'rgba(100,255,150,0.4)':'rgba(255,100,100,0.4)';ctx.lineWidth=2;ctx.beginPath();ctx.arc(state.cursorPos.x,state.cursorPos.y,100*settingsRef.current.cursorStrength,0,Math.PI*2);ctx.stroke()}
      if(pausedRef.current){ctx.fillStyle='rgba(0,0,0,0.3)';ctx.fillRect(0,0,w,h);ctx.fillStyle='white';ctx.font='48px sans-serif';ctx.textAlign='center';ctx.fillText('PAUSED',w/2,h/2)}
      
      animRef.current=requestAnimationFrame(animate)
    };
    ctx.fillStyle='rgb(12,12,22)';ctx.fillRect(0,0,canvas.width,canvas.height);animate();
    return()=>{if(animRef.current)cancelAnimationFrame(animRef.current)}
  },[initWorld,addRipple,addDangerZone,addMutationLog]);
  
  const handleClick=e=>{const rect=canvasRef.current.getBoundingClientRect();const x=(e.clientX-rect.left)*(canvasRef.current.width/rect.width),y=(e.clientY-rect.top)*(canvasRef.current.height/rect.height);const state=stateRef.current;
    if(tool==='select'){const clicked=state.boids.find(b=>b.position.distSq(new Vector2(x,y))<225);if(clicked){setSelectedBoid(clicked.id);setShowMutationPanel(true)}return}
    if(tool==='favorite'){const clicked=state.boids.find(b=>b.position.distSq(new Vector2(x,y))<225);if(clicked)setFavoriteBoid(f=>f===clicked.id?null:clicked.id);return}
    switch(tool){
      case'obstacle':state.obstacles.push(new Vector2(x,y));break;
      case'remove':state.obstacles=state.obstacles.filter(o=>{const dx=o.x-x,dy=o.y-y;return dx*dx+dy*dy>400});break;
      case'predator':const np=state.predators.find(p=>p.position.distSq(new Vector2(x,y))<6400);state.predators.push(new Predator(x,y,np?.packId??state.nextPackId++));addRipple(x,y,'rgb(255,50,50)',35);break;
      case'food':state.food.push(new FoodSource(x,y));addRipple(x,y,'rgb(100,255,150)',25);break;
      case'shelter':state.shelters.push(new Shelter(x,y));break;
      case'nest':state.nests.push(new Nest(x,y,Math.random()>0.5?0:1));break;
      case'boid':const sp=Math.random()>0.5?0:1;for(let i=0;i<8;i++)state.boids.push(new Boid(x+(Math.random()-0.5)*40,y+(Math.random()-0.5)*40,sp,null,false,null,settingsRef.current.mutationMult));addRipple(x,y,'rgb(150,200,255)',40);break;
    }
  };
  
  const resizeCanvas=(newW,newH)=>{setCanvasSize({w:newW,h:newH});stateRef.current.width=newW;stateRef.current.height=newH;setTimeout(()=>initWorld(newW,newH),50)};
  
  const tools=[{id:'food',label:'üåø'},{id:'obstacle',label:'ü™®'},{id:'remove',label:'‚ùå'},{id:'predator',label:'üëÅ'},{id:'shelter',label:'üè†'},{id:'nest',label:'ü™∫'},{id:'boid',label:'üê¶'},{id:'select',label:'üëÜ'},{id:'favorite',label:'‚≠ê'}];
  
  return(
    <div className="flex flex-col items-center gap-1 p-2 bg-gray-900 min-h-screen">
      <div className="flex items-center gap-3 flex-wrap justify-center">
        <h1 className="text-base font-bold text-cyan-400">Living World</h1>
        <span className="text-gray-500 text-xs">{stats.day?'‚òÄÔ∏è':'üåô'} {stats.season} ‚Ä¢ {stats.boids} boids ‚Ä¢ {stats.predators} pred ‚Ä¢ {stats.bugs} bugs ‚Ä¢ {stats.fps}fps</span>
        {stats.mutants>0&&<span className="text-purple-400 text-xs cursor-pointer hover:text-purple-300" onClick={()=>setShowDNALab(true)} title="Open DNA Lab">üß¨ {stats.mutants}{stats.multiMutants>0&&<span className="text-pink-400"> ({stats.multiMutants})</span>}</span>}
      </div>
      
      <canvas ref={canvasRef} width={canvasSize.w} height={canvasSize.h} onClick={handleClick} onMouseMove={e=>{const rect=canvasRef.current.getBoundingClientRect();stateRef.current.cursorPos=new Vector2((e.clientX-rect.left)*(canvasRef.current.width/rect.width),(e.clientY-rect.top)*(canvasRef.current.height/rect.height))}} onMouseLeave={()=>stateRef.current.cursorPos=null} className="border border-gray-700 rounded cursor-crosshair"/>
      
      <div className="flex flex-wrap justify-center items-center gap-1">
        <button onClick={()=>setPaused(p=>!p)} className={`px-2 py-0.5 rounded text-xs font-bold ${paused?'bg-green-600':'bg-yellow-600'}`}>{paused?'‚ñ∂':'‚è∏'}</button>
        {tools.map(t=><button key={t.id} onClick={()=>setTool(t.id)} className={`w-7 h-7 rounded text-sm ${tool===t.id?'bg-cyan-600':'bg-gray-700 hover:bg-gray-600'}`} title={t.id}>{t.label}</button>)}
        <span className="mx-1 text-gray-600">|</span>
        {['none','attract','repel'].map(m=><button key={m} onClick={()=>setCursorMode(m)} className={`px-2 py-0.5 rounded text-xs ${cursorMode===m?m==='attract'?'bg-green-600':m==='repel'?'bg-red-600':'bg-gray-600':'bg-gray-700'}`}>{m==='none'?'‚Äî':m==='attract'?'üß≤':'üí®'}</button>)}
        {cursorMode!=='none'&&<><label className="flex items-center gap-1 text-xs"><input type="checkbox" checked={vortexBoids} onChange={e=>setVortexBoids(e.target.checked)} className="w-3 h-3"/><span className="text-cyan-400">üê¶</span></label><label className="flex items-center gap-1 text-xs"><input type="checkbox" checked={vortexPredators} onChange={e=>setVortexPredators(e.target.checked)} className="w-3 h-3"/><span className="text-red-400">üëÅ</span></label></>}
        <span className="mx-1 text-gray-600">|</span>
        <button onClick={()=>setShowTrails(t=>!t)} className={`px-2 py-0.5 rounded text-xs ${showTrails?'bg-purple-600':'bg-gray-700'}`}>‚ú®</button>
        <button onClick={()=>{mutationLogRef.current=[];setMutationLog([]);setFavoriteBoid(null);initWorld(canvasSize.w,canvasSize.h)}} className="px-2 py-0.5 bg-gray-700 rounded text-xs">üîÑ</button>
      </div>
      
      <div className="w-full max-w-5xl mt-1 p-2 bg-gray-800 rounded border border-gray-700">
        <div className="flex flex-wrap gap-4 justify-center items-center text-xs">
          <label className="flex items-center gap-1"><span className="text-gray-400">Pop Cap</span><input type="number" defaultValue={150} onBlur={e=>{settingsRef.current.popCap=Math.max(10,Math.min(1000,parseInt(e.target.value)||150))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Speed</span><input type="number" defaultValue={1} step={0.5} onBlur={e=>{settingsRef.current.gameSpeed=Math.max(0.5,Math.min(10,parseFloat(e.target.value)||1))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Mut√ó</span><input type="number" defaultValue={1} step={0.5} onBlur={e=>{settingsRef.current.mutationMult=Math.max(0,Math.min(10,parseFloat(e.target.value)||1))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Birth√ó</span><input type="number" defaultValue={1} step={0.5} onBlur={e=>{settingsRef.current.birthMult=Math.max(0,Math.min(10,parseFloat(e.target.value)||1))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Bug√ó</span><input type="number" defaultValue={1} step={0.5} onBlur={e=>{settingsRef.current.bugMult=Math.max(0,Math.min(10,parseFloat(e.target.value)||1))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Start</span><input type="number" defaultValue={60} onBlur={e=>{settingsRef.current.startBoids=Math.max(10,Math.min(500,parseInt(e.target.value)||60))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Vortex</span><input type="range" min="0.1" max="3" step="0.1" defaultValue="1" onChange={e=>{settingsRef.current.cursorStrength=parseFloat(e.target.value)}} className="w-16"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Pred</span><button onClick={()=>{settingsRef.current.predBreeding=!settingsRef.current.predBreeding;}} className="px-2 py-0.5 rounded bg-gray-600 hover:bg-gray-500">{settingsRef.current.predBreeding?'ON':'OFF'}</button></label>
          <div className="flex items-center gap-1"><span className="text-gray-400">Size</span><button onClick={()=>resizeCanvas(900,450)} className={`px-1 py-0.5 rounded ${canvasSize.w===900?'bg-cyan-600':'bg-gray-700'}`}>M</button><button onClick={()=>resizeCanvas(1200,550)} className={`px-1 py-0.5 rounded ${canvasSize.w===1200?'bg-cyan-600':'bg-gray-700'}`}>L</button><button onClick={()=>resizeCanvas(1400,650)} className={`px-1 py-0.5 rounded ${canvasSize.w===1400?'bg-cyan-600':'bg-gray-700'}`}>XL</button></div>
        </div>
      </div>
      
      {showMutationPanel&&selectedBoid&&(
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={()=>setShowMutationPanel(false)}>
          <div className="bg-gray-800 p-4 rounded-lg border border-gray-600 max-w-2xl max-h-96 overflow-y-auto" onClick={e=>e.stopPropagation()}>
            <div className="flex justify-between items-center mb-3"><h3 className="text-cyan-400 font-bold">Give Mutation to Bird</h3><button onClick={()=>setShowMutationPanel(false)} className="text-gray-400 hover:text-white">‚úï</button></div>
            <div className="grid grid-cols-4 gap-2">
              {Object.entries(mutationInfo).map(([key,info])=>(
                <button key={key} onClick={()=>{giveMutation(selectedBoid,key);setShowMutationPanel(false)}} className={`p-2 rounded text-xs text-left hover:bg-gray-700 ${info.type==='good'?'bg-green-900/30':info.type==='bad'?'bg-red-900/30':info.type==='special'?'bg-purple-900/30':'bg-gray-700/50'}`}>
                  <div className="flex items-center gap-1"><span>{info.emoji}</span><span style={{color:info.color}}>{info.name}</span></div>
                  <div className="text-gray-500 text-xs mt-1">{info.desc}</div>
                </button>
              ))}
            </div>
          </div>
        </div>
      )}

      {showPredMutPanel&&selectedPredator&&(
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={()=>setShowPredMutPanel(false)}>
          <div className="bg-gray-800 p-4 rounded-lg border border-red-600 max-w-2xl max-h-96 overflow-y-auto" onClick={e=>e.stopPropagation()}>
            <div className="flex justify-between items-center mb-3"><h3 className="text-red-400 font-bold">Give Mutation to Predator</h3><button onClick={()=>setShowPredMutPanel(false)} className="text-gray-400 hover:text-white">‚úï</button></div>
            <div className="grid grid-cols-4 gap-2">
              {Object.entries(mutationInfo).filter(([k])=>!['cannibal','traitor','egggiver','phoenix','tasty','bullied','fertile'].includes(k)).map(([key,info])=>(
                <button key={key} onClick={()=>{givePredatorMutation(selectedPredator,key);setShowPredMutPanel(false)}} className={`p-2 rounded text-xs text-left hover:bg-gray-700 ${info.type==='good'?'bg-green-900/30':info.type==='bad'?'bg-red-900/30':info.type==='special'?'bg-purple-900/30':'bg-gray-700/50'}`}>
                  <div className="flex items-center gap-1"><span>{info.emoji}</span><span style={{color:info.color}}>{info.name}</span></div>
                  <div className="text-gray-500 text-xs mt-1">{info.desc}</div>
                </button>
              ))}
            </div>
          </div>
        </div>
      )}

      {showDNALab&&(
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={()=>setShowDNALab(false)}>
          <div className="bg-gray-900 p-6 rounded-lg border border-purple-500 max-w-4xl max-h-[80vh] overflow-y-auto" onClick={e=>e.stopPropagation()}>
            <div className="flex justify-between items-center mb-4"><h3 className="text-purple-400 font-bold text-lg">üß¨ DNA Lab - Mutation Statistics</h3><button onClick={()=>setShowDNALab(false)} className="text-gray-400 hover:text-white text-xl">‚úï</button></div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <h4 className="text-green-400 font-bold mb-2">Good Mutations ({Object.entries(mutationInfo).filter(([,i])=>i.type==='good').length})</h4>
                <div className="space-y-1">{Object.entries(mutationInfo).filter(([,i])=>i.type==='good').map(([key,info])=>{
                  const count=stateRef.current.boids.filter(b=>b.mutations[key]).length;
                  return<div key={key} className="flex items-center justify-between p-1.5 rounded bg-green-900/20 border border-green-800/30">
                    <div className="flex items-center gap-2"><span>{info.emoji}</span><span style={{color:info.color}} className="font-medium">{info.name}</span></div>
                    <div className="flex items-center gap-2"><span className="text-gray-400 text-xs">{info.desc}</span><span className="text-green-400 font-bold">{count}</span></div>
                  </div>})}</div>
              </div>
              <div>
                <h4 className="text-red-400 font-bold mb-2">Bad Mutations ({Object.entries(mutationInfo).filter(([,i])=>i.type==='bad').length})</h4>
                <div className="space-y-1 mb-4">{Object.entries(mutationInfo).filter(([,i])=>i.type==='bad').map(([key,info])=>{
                  const count=stateRef.current.boids.filter(b=>b.mutations[key]).length;
                  return<div key={key} className="flex items-center justify-between p-1.5 rounded bg-red-900/20 border border-red-800/30">
                    <div className="flex items-center gap-2"><span>{info.emoji}</span><span style={{color:info.color}} className="font-medium">{info.name}</span></div>
                    <div className="flex items-center gap-2"><span className="text-gray-400 text-xs">{info.desc}</span><span className="text-red-400 font-bold">{count}</span></div>
                  </div>})}</div>
                <h4 className="text-yellow-400 font-bold mb-2">Neutral ({Object.entries(mutationInfo).filter(([,i])=>i.type==='neutral').length})</h4>
                <div className="space-y-1">{Object.entries(mutationInfo).filter(([,i])=>i.type==='neutral').map(([key,info])=>{
                  const count=stateRef.current.boids.filter(b=>b.mutations[key]).length;
                  return<div key={key} className="flex items-center justify-between p-1.5 rounded bg-yellow-900/20 border border-yellow-800/30">
                    <div className="flex items-center gap-2"><span>{info.emoji}</span><span style={{color:info.color}} className="font-medium">{info.name}</span></div>
                    <div className="flex items-center gap-2"><span className="text-gray-400 text-xs">{info.desc}</span><span className="text-yellow-400 font-bold">{count}</span></div>
                  </div>})}</div>
              </div>
            </div>
            <div className="mt-4 pt-4 border-t border-gray-700">
              <h4 className="text-purple-400 font-bold mb-2">Special Mutations</h4>
              <div className="flex gap-2">{Object.entries(mutationInfo).filter(([,i])=>i.type==='special').map(([key,info])=>{
                const count=stateRef.current.boids.filter(b=>b.mutations[key]).length;
                return<div key={key} className="flex items-center gap-2 p-2 rounded bg-purple-900/20 border border-purple-800/30">
                  <span>{info.emoji}</span><span style={{color:info.color}} className="font-medium">{info.name}</span><span className="text-purple-400 font-bold">({count})</span>
                </div>})}</div>
            </div>
            <div className="mt-4 pt-4 border-t border-gray-700">
              <h4 className="text-cyan-400 font-bold mb-2">Quick Actions</h4>
              <div className="flex flex-wrap gap-2">
                <button onClick={()=>{stateRef.current.boids.forEach(b=>{if(Object.keys(b.mutations).length===0){const muts=Object.keys(mutationInfo).filter(m=>m!=='egggiver'&&m!=='phoenix'&&m!=='mimic');b.mutations[muts[Math.floor(Math.random()*muts.length)]]=true;b.applyMutationEffects()}})}} className="px-3 py-1.5 bg-purple-700 hover:bg-purple-600 rounded text-sm">Give All Boids Random Mutation</button>
                <button onClick={()=>{stateRef.current.boids.forEach(b=>{const goodMuts=Object.entries(mutationInfo).filter(([,i])=>i.type==='good').map(([k])=>k);const mut=goodMuts[Math.floor(Math.random()*goodMuts.length)];b.mutations[mut]=true;b.applyMutationEffects()})}} className="px-3 py-1.5 bg-green-700 hover:bg-green-600 rounded text-sm">Give All Good Mutation</button>
                <button onClick={()=>{stateRef.current.boids.forEach(b=>{b.mutations.fighter=true;b.applyMutationEffects()})}} className="px-3 py-1.5 bg-red-700 hover:bg-red-600 rounded text-sm">‚öîÔ∏è Give All Fighter</button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      <div className="w-full max-w-5xl mt-1 flex gap-2">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-1"><button className="text-gray-500 hover:text-white text-xs" onClick={()=>setShowRoster(r=>!r)}>{showRoster?'‚ñº':'‚ñ∂'}</button><span className="text-pink-400 text-sm font-bold cursor-pointer" onClick={()=>setShowRoster(r=>!r)}>üß¨ Mutant Roster</span><span className="text-gray-600 text-xs">({rosterData.length})</span>{showRoster&&<button className="text-gray-500 hover:text-white text-xs ml-auto" onClick={()=>setExpandRoster(e=>!e)}>{expandRoster?'‚ñ´':'‚ñ™'}</button>}</div>
          {showRoster&&<div className={`bg-gray-800 rounded border border-gray-700 overflow-y-auto scroll-stable ${expandRoster?'h-72':'h-36'}`}>
            {rosterData.length===0?<div className="flex items-center justify-center h-full text-gray-600 text-sm">No mutants yet</div>:
            <div className="p-1.5 space-y-1">{rosterData.map(boid=>{
              const speciesName=boid.isHybrid?'Hybrid':boid.species===0?'Cyan':'Gold';
              const speciesColor=boid.isHybrid?'text-green-400':boid.species===0?'text-cyan-400':'text-yellow-400';
              const isFav=boid.id===favoriteBoid;
              const lifePercent=Math.round((boid.energy/boid.maxEnergy)*100);
              const lifeColor=lifePercent>60?'text-green-400':lifePercent>30?'text-yellow-400':'text-red-400';
              const agePercent=Math.round((boid.age/boid.maxAge)*100);
              return<div key={boid.id} className={`p-1.5 rounded bg-gray-900/50 border-l-2 ${isFav?'border-yellow-400':'border-purple-500'} cursor-pointer hover:bg-gray-700/50`} onClick={()=>{setSelectedBoid(boid.id);setShowMutationPanel(true)}}>
                <div className="flex items-center gap-2 text-xs flex-wrap">
                  <span className={`font-bold ${speciesColor}`}>{speciesName}</span>
                  <span className={lifeColor}>‚ù§Ô∏è{lifePercent}%</span>
                  <span className="text-gray-500">‚è≥{agePercent}%</span>
                  {isFav&&<span className="text-yellow-400">‚≠ê</span>}
                  {boid.hasArmor&&<span className="text-blue-400">üõ°Ô∏è</span>}
                </div>
                <div className="flex flex-wrap gap-1 mt-1">{boid.mutations.map(mut=>{const info=mutationInfo[mut];return info?<span key={mut} className="inline-flex items-center gap-0.5 px-1 rounded text-xs" style={{backgroundColor:info.color+'22',color:info.color}}><span>{info.emoji}</span><span>{info.name}</span></span>:null})}</div>
              </div>})}</div>}
          </div>}
        </div>
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-1"><button className="text-gray-500 hover:text-white text-xs" onClick={()=>setShowLog(l=>!l)}>{showLog?'‚ñº':'‚ñ∂'}</button><span className="text-purple-400 text-sm font-bold cursor-pointer" onClick={()=>setShowLog(l=>!l)}>üìú Mutation Log</span><span className="text-gray-600 text-xs">({mutationLog.length})</span>{showLog&&<button className="text-gray-500 hover:text-white text-xs ml-auto" onClick={()=>setExpandLog(e=>!e)}>{expandLog?'‚ñ´':'‚ñ™'}</button>}</div>
          {showLog&&<div className={`bg-gray-800 rounded border border-gray-700 overflow-y-auto scroll-stable ${expandLog?'h-72':'h-36'}`}>
            {mutationLog.length===0?<div className="flex items-center justify-center h-full text-gray-600 text-sm">Waiting for mutations...</div>:
            <div className="p-2 space-y-1.5">{mutationLog.map(entry=>{
              const eventLabel=entry.event==='new'?'New Mutation':entry.event==='given'?'Given':entry.event==='given_pred'?'Given Pred':entry.event==='egg'?'Egg Birth':entry.event==='inherited'?'Inherited':entry.event==='both'?'Both Parents':entry.event==='armor_broke'?'Armor Broke':entry.event==='evolved'?'Evolved':entry.event==='killed_pred'?'‚öîÔ∏è KILLED PRED':'Event';
              const eventColor=entry.event==='new'?'bg-yellow-500/20 text-yellow-400 border-yellow-500/30':entry.event==='given'||entry.event==='given_pred'?'bg-orange-500/20 text-orange-400 border-orange-500/30':entry.event==='egg'?'bg-pink-500/20 text-pink-400 border-pink-500/30':entry.event==='armor_broke'?'bg-blue-500/20 text-blue-400 border-blue-500/30':entry.event==='evolved'?'bg-red-500/20 text-red-400 border-red-500/30':entry.event==='killed_pred'?'bg-red-600/40 text-red-300 border-red-400/50':'bg-purple-500/20 text-purple-400 border-purple-500/30';
              const speciesColor=entry.speciesName==='Hybrid'?'text-green-400':entry.speciesName==='Cyan'?'text-cyan-400':entry.speciesName==='Predator'?'text-red-400':'text-yellow-400';
              return<div key={entry.id} className="flex items-center gap-2 p-1.5 rounded bg-gray-900/30 text-xs">
                <span className="text-gray-500 w-14">{entry.timestamp}</span>
                <span>{entry.info.emoji}</span>
                <span style={{color:entry.info.color}} className="font-medium">{entry.info.name}</span>
                <span className={`px-1.5 py-0.5 rounded border ${eventColor}`}>{eventLabel}</span>
                <span className={speciesColor}>{entry.speciesName}</span>
              </div>})}</div>}
          </div>}
        </div>
      </div>

      {predatorRoster.length>0&&(
      <div className="w-full max-w-5xl mt-1">
        <div className="flex items-center gap-2 mb-1"><span className="text-red-400 text-sm font-bold">üëÅ Predator Roster</span><span className="text-gray-600 text-xs">({predatorRoster.length} predators)</span></div>
        <div className="bg-gray-800 rounded border border-red-900 h-32 overflow-y-auto scroll-stable">
          <div className="p-2 flex flex-wrap gap-2">{predatorRoster.map(pred=>(
            <div key={pred.id} className={`p-2 rounded bg-red-900/20 border ${pred.isLeader?'border-yellow-500':'border-red-700'} cursor-pointer hover:bg-red-900/40`} onClick={()=>{setSelectedPredator(pred.id);setShowPredMutPanel(true)}}>
              <div className="flex items-center gap-2 mb-1">
                <span className="text-red-400 font-bold">Gen {pred.generation}</span>
                {pred.isLeader&&<span className="text-yellow-400">üëë</span>}
                <span className="text-gray-400 text-xs">‚öîÔ∏è {pred.kills} kills</span>
              </div>
              <div className="flex items-center gap-1 text-xs">
                <span className={pred.energy>100?'text-green-400':pred.energy>50?'text-yellow-400':'text-red-400'}>‚ù§Ô∏è {Math.round(pred.energy)}%</span>
              </div>
              {pred.mutations.length>0&&<div className="flex flex-wrap gap-1 mt-1">{pred.mutations.map(mut=>{const info=mutationInfo[mut];return info?<span key={mut} className="inline-flex items-center gap-0.5 px-1 rounded text-xs" style={{backgroundColor:info.color+'22',color:info.color}}><span>{info.emoji}</span><span>{info.name}</span></span>:null})}</div>}
            </div>
          ))}</div>
        </div>
      </div>
      )}
      
      <div className="w-full max-w-5xl mt-1 p-1 bg-gray-800/50 rounded border border-gray-700 cursor-pointer" onClick={()=>setExpandLegend(e=>!e)}>
        <div className="flex flex-wrap gap-1 justify-center">{Object.entries(mutationInfo).map(([key,info])=>expandLegend?<span key={key} className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-xs" style={{backgroundColor:info.color+'15',color:info.color,border:`1px solid ${info.color}33`}} title={info.desc}><span>{info.emoji}</span><span>{info.name}</span></span>:<span key={key} className="text-sm" style={{color:info.color}} title={`${info.name}: ${info.desc}`}>{info.emoji}</span>)}</div>
      </div>
    </div>
  )
}

ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
</script>
</body>
</html>
