<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boids Simulation</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>body{margin:0;background:#111827;}input[type=number],input[type=range]{-moz-appearance:textfield;}input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}.scroll-stable{overflow-anchor:none;}</style>
</head>
<body>
<div id="root"></div>
<script type="module">
import init, { WasmWorld } from './pkg/boids.js';

const {useState,useEffect,useRef,useCallback}=React;

// Visual effect classes (rendering only)
class Ripple{
  constructor(x,y,color,maxRadius=40){this.x=x;this.y=y;this.radius=5;this.maxRadius=maxRadius;this.color=color;this.alpha=0.8}
  update(){this.radius+=2;this.alpha-=0.03;return this.alpha>0}
  draw(ctx){ctx.strokeStyle=this.color.replace(')',`,${this.alpha})`).replace('rgb','rgba');ctx.lineWidth=2;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.stroke()}
}

class DangerZone{
  constructor(x,y){this.x=x;this.y=y;this.intensity=1;this.radius=70}
  update(){this.intensity-=0.002;return this.intensity>0}
  draw(ctx){const g=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.radius);g.addColorStop(0,`rgba(255,0,0,${this.intensity*0.1})`);g.addColorStop(1,'rgba(255,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.fill()}
}

class Shelter{
  constructor(x,y){this.x=x;this.y=y;this.radius=50}
  draw(ctx,dayPhase){ctx.fillStyle=`rgba(40,35,30,${0.8+(1-dayPhase)*0.2})`;ctx.beginPath();ctx.arc(this.x,this.y+10,this.radius,Math.PI,0);ctx.fill();ctx.strokeStyle='rgba(100,200,100,0.2)';ctx.setLineDash([5,5]);ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.stroke();ctx.setLineDash([])}
}

class Nest{
  constructor(x,y,species){this.x=x;this.y=y;this.species=species}
  draw(ctx){ctx.fillStyle=`hsla(${this.species===0?30:45},40%,30%,0.6)`;ctx.beginPath();ctx.ellipse(this.x,this.y,20,12,0,0,Math.PI*2);ctx.fill()}
}

class Tree{
  constructor(x,y){this.x=x;this.y=y;this.height=60+Math.random()*40;this.width=40+Math.random()*20}
  draw(ctx,dayPhase){ctx.fillStyle=`rgba(60,40,30,${0.8+dayPhase*0.2})`;ctx.fillRect(this.x-8,this.y-this.height,16,this.height);ctx.fillStyle=`rgba(${30+dayPhase*20},${80+dayPhase*40},${30+dayPhase*20},0.9)`;ctx.beginPath();ctx.ellipse(this.x,this.y-this.height,this.width/2,this.height*0.4,0,0,Math.PI*2);ctx.fill();ctx.fillStyle=`rgba(${20+dayPhase*15},${60+dayPhase*30},${20+dayPhase*15},0.8)`;ctx.beginPath();ctx.ellipse(this.x-10,this.y-this.height+10,this.width*0.3,this.height*0.25,0,0,Math.PI*2);ctx.fill()}
}

class Pond{
  constructor(x,y,w,h){this.x=x;this.y=y;this.width=w;this.height=h;this.fish=[];this.maxFish=8}
  update(){if(this.fish.length<this.maxFish&&Math.random()<0.01)this.fish.push({x:(Math.random()-0.5)*this.width*0.8,y:(Math.random()-0.5)*this.height*0.6,phase:Math.random()*Math.PI*2});for(let f of this.fish){f.x+=Math.sin(f.phase)*0.3;f.phase+=0.02}}
  draw(ctx){const g=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,Math.max(this.width,this.height)/2);g.addColorStop(0,'rgba(30,80,120,0.8)');g.addColorStop(0.7,'rgba(40,100,140,0.7)');g.addColorStop(1,'rgba(50,120,160,0.5)');ctx.fillStyle=g;ctx.beginPath();ctx.ellipse(this.x,this.y,this.width/2,this.height/2,0,0,Math.PI*2);ctx.fill();ctx.fillStyle='rgba(255,150,50,0.7)';for(let f of this.fish){ctx.beginPath();ctx.ellipse(this.x+f.x,this.y+f.y,4,2,Math.sin(f.phase)*0.3,0,Math.PI*2);ctx.fill()}}
}

// Mutation definitions with bit positions matching Rust
const mutationDefs=[
  {bit:0,key:'giant',name:'Giant',emoji:'ðŸ¦£',color:'#f97316',bg:'#7c2d12'},
  {bit:1,key:'tiny',name:'Tiny',emoji:'ðŸœ',color:'#a3e635',bg:'#365314'},
  {bit:2,key:'speedy',name:'Speedy',emoji:'âš¡',color:'#22d3ee',bg:'#164e63'},
  {bit:3,key:'glowing',name:'Glowing',emoji:'âœ¨',color:'#fbbf24',bg:'#78350f'},
  {bit:4,key:'tough',name:'Tough',emoji:'ðŸ›¡ï¸',color:'#64748b',bg:'#334155'},
  {bit:5,key:'longlived',name:'Long-lived',emoji:'ðŸ•°ï¸',color:'#c084fc',bg:'#581c87'},
  {bit:6,key:'fertile',name:'Fertile',emoji:'ðŸ¥š',color:'#fb7185',bg:'#881337'},
  {bit:7,key:'camouflage',name:'Camouflage',emoji:'ðŸƒ',color:'#4ade80',bg:'#14532d'},
  {bit:8,key:'nocturnal',name:'Nocturnal',emoji:'ðŸ¦‰',color:'#60a5fa',bg:'#1e3a5f'},
  {bit:9,key:'magnetic',name:'Magnetic',emoji:'ðŸ§²',color:'#f472b6',bg:'#831843'},
  {bit:10,key:'rainbow',name:'Rainbow',emoji:'ðŸŒˆ',color:'#ec4899',bg:'#831843'},
  {bit:11,key:'ravenous',name:'Ravenous',emoji:'ðŸ˜‹',color:'#ea580c',bg:'#7c2d12'},
  {bit:12,key:'plated',name:'Plated',emoji:'ðŸª–',color:'#a8a29e',bg:'#44403c'},
  {bit:13,key:'zen',name:'Zen',emoji:'ðŸ§˜',color:'#a78bfa',bg:'#4c1d95'},
  {bit:14,key:'cannibal',name:'Cannibal',emoji:'ðŸ’€',color:'#dc2626',bg:'#7f1d1d'},
  {bit:15,key:'immortal',name:'Immortal',emoji:'â™¾ï¸',color:'#fcd34d',bg:'#78350f'},
  {bit:16,key:'bigstomach',name:'Big Stomach',emoji:'ðŸ”',color:'#f59e0b',bg:'#78350f'},
  {bit:17,key:'smallstomach',name:'Small Stomach',emoji:'ðŸ¥—',color:'#84cc16',bg:'#365314'},
  {bit:18,key:'traitor',name:'Traitor',emoji:'ðŸŽ­',color:'#7c3aed',bg:'#4c1d95'},
  {bit:19,key:'egggiver',name:'Egg Giver',emoji:'ðŸ£',color:'#fde047',bg:'#713f12'},
  {bit:20,key:'fat',name:'Fat',emoji:'ðŸ·',color:'#fdba74',bg:'#7c2d12'},
  {bit:21,key:'paper',name:'Paper',emoji:'ðŸ“„',color:'#e2e8f0',bg:'#475569'},
  {bit:22,key:'flightless',name:'Flightless',emoji:'ðŸ§',color:'#0ea5e9',bg:'#0c4a6e'},
  {bit:23,key:'mechanical',name:'Mechanical',emoji:'ðŸ¤–',color:'#9ca3af',bg:'#374151'},
  {bit:24,key:'tasty',name:'Tasty',emoji:'ðŸ–',color:'#f87171',bg:'#7f1d1d'},
  {bit:25,key:'aggressive',name:'Aggressive',emoji:'ðŸ˜¤',color:'#ef4444',bg:'#7f1d1d'},
  {bit:26,key:'bullied',name:'Bullied',emoji:'ðŸ˜¢',color:'#94a3b8',bg:'#334155'}
];

// Decode mutation bits to list of mutation keys
function decodeMutations(bits){
  const result=[];
  const b=Math.floor(bits);
  for(const m of mutationDefs){
    if(b&(1<<m.bit))result.push(m);
  }
  return result;
}

function App({wasmWorld}){
  const canvasRef=useRef(null);
  const worldRef=useRef(wasmWorld);
  const effectsRef=useRef({ripples:[],dangerZones:[],trees:[],shelters:[],nests:[],pond:null,time:0});
  const settingsRef=useRef({gameSpeed:1,cursorStrength:1,startBoids:60});
  const animRef=useRef(null);
  const[tool,setTool]=useState('food');const[showTrails,setShowTrails]=useState(false);const[cursorMode,setCursorMode]=useState('none');
  const[stats,setStats]=useState({boids:0,day:true,predators:0,bugs:0,fps:60});
  const[paused,setPaused]=useState(false);
  const[canvasSize,setCanvasSize]=useState({w:900,h:450});
  const[rosterData,setRosterData]=useState([]);
  const[rosterOpen,setRosterOpen]=useState(true);
  const[legendOpen,setLegendOpen]=useState(true);

  const pausedRef=useRef(false);const showTrailsRef=useRef(false);const cursorModeRef=useRef('none');
  const lastFrameTime=useRef(performance.now());const fpsRef=useRef(60);
  const cursorPosRef=useRef({x:0,y:0,active:false});

  useEffect(()=>{pausedRef.current=paused},[paused]);
  useEffect(()=>{showTrailsRef.current=showTrails},[showTrails]);
  useEffect(()=>{cursorModeRef.current=cursorMode},[cursorMode]);

  const addRipple=useCallback((x,y,color,size)=>{effectsRef.current.ripples.push(new Ripple(x,y,color,size))},[]);
  const addDangerZone=useCallback((x,y)=>{const eff=effectsRef.current;for(const z of eff.dangerZones){const dx=z.x-x,dy=z.y-y;if(dx*dx+dy*dy<1600)return}eff.dangerZones.push(new DangerZone(x,y))},[]);

  const initEffects=useCallback((w,h)=>{
    const eff=effectsRef.current;
    eff.ripples=[];eff.dangerZones=[];eff.time=0;
    eff.trees=[new Tree(w*0.1,h-30),new Tree(w*0.3,h-35),new Tree(w*0.5,h-30),new Tree(w*0.7,h-40),new Tree(w*0.9,h-30)];
    eff.shelters=[new Shelter(80,h-100),new Shelter(w-80,h-100)];
    eff.nests=[new Nest(w*0.22,h-130,0),new Nest(w*0.78,h-130,1)];
    eff.pond=new Pond(w*0.5,h-80,100,50);
  },[]);

  useEffect(()=>{
    const canvas=canvasRef.current;const ctx=canvas.getContext('2d');
    const world=worldRef.current;
    initEffects(canvas.width,canvas.height);

    const animate=()=>{
      const now=performance.now();const delta=now-lastFrameTime.current;lastFrameTime.current=now;
      fpsRef.current=fpsRef.current*0.9+(1000/delta)*0.1;

      const eff=effectsRef.current;
      const w=canvas.width,h=canvas.height;

      if(!pausedRef.current){
        const spd=Math.max(1,Math.floor(settingsRef.current.gameSpeed));
        for(let tick=0;tick<spd;tick++){
          eff.time+=16;
          const cMode=cursorModeRef.current==='attract'?1:cursorModeRef.current==='repel'?2:0;
          const cx=cursorPosRef.current.active?cursorPosRef.current.x:-1;
          const cy=cursorPosRef.current.active?cursorPosRef.current.y:-1;
          world.tick(cx,cy,cMode,settingsRef.current.cursorStrength);
          if(eff.pond)eff.pond.update();
          eff.ripples=eff.ripples.filter(r=>r.update());
          eff.dangerZones=eff.dangerZones.filter(z=>z.update());
        }
      }

      const statsData=world.get_stats();
      const boidCount=statsData[0];
      const predatorCount=statsData[1];
      const bugCount=statsData[2];
      const dayPhase=statsData[3];
      const isDay=dayPhase>0.45;

      // Update stats and roster (throttled)
      if(eff.time%500<20||pausedRef.current){
        setStats({boids:Math.round(boidCount),day:isDay,predators:Math.round(predatorCount),bugs:Math.round(bugCount),fps:Math.round(fpsRef.current)});

        // Build roster from boid data
        const boidData=world.get_boid_data();
        const roster=[];
        for(let i=0;i<boidData.length;i+=11){
          const mutations=boidData[i+8];
          if(mutations>0){
            const energy=boidData[i+5];
            const maxEnergy=boidData[i+6];
            const hue=boidData[i+4];
            const species=hue>100&&hue<160?'H':hue<100?'G':'C';
            roster.push({
              idx:i/11,
              species,
              energy,
              maxEnergy,
              lifePercent:Math.round((energy/maxEnergy)*100),
              mutations:decodeMutations(mutations)
            });
          }
        }
        roster.sort((a,b)=>b.mutations.length-a.mutations.length);
        setRosterData(roster.slice(0,20));
      }

      // Render
      ctx.fillStyle=`rgba(${12+dayPhase*12},${12+dayPhase*18},${22+dayPhase*25},0.25)`;ctx.fillRect(0,0,w,h);
      for(const z of eff.dangerZones)z.draw(ctx);
      if(eff.pond)eff.pond.draw(ctx);
      for(const s of eff.shelters)s.draw(ctx,dayPhase);
      for(const n of eff.nests)n.draw(ctx);
      for(const t of eff.trees)t.draw(ctx,dayPhase);

      const obstacleData=world.get_obstacle_data();
      for(let i=0;i<obstacleData.length;i+=2){
        const ox=obstacleData[i],oy=obstacleData[i+1];
        ctx.fillStyle='rgba(80,70,60,0.9)';ctx.beginPath();ctx.arc(ox,oy,14,0,Math.PI*2);ctx.fill();
      }

      const foodData=world.get_food_data();
      const time=eff.time;
      for(let i=0;i<foodData.length;i+=3){
        const fx=foodData[i],fy=foodData[i+1],amount=foodData[i+2];
        if(amount>0){
          const pulse=(Math.sin(time*0.003)+1)/2*0.2+0.8;
          const r=25*(amount/100)*pulse;
          const g=ctx.createRadialGradient(fx,fy,0,fx,fy,r*1.5);
          g.addColorStop(0,`rgba(100,255,150,${0.5*pulse})`);
          g.addColorStop(1,'rgba(100,255,150,0)');
          ctx.fillStyle=g;ctx.beginPath();ctx.arc(fx,fy,r*1.5,0,Math.PI*2);ctx.fill();
        }
      }

      const bugData=world.get_bug_data();
      for(let i=0;i<bugData.length;i+=4){
        const bx=bugData[i],by=bugData[i+1],hue=bugData[i+2],size=bugData[i+3];
        ctx.fillStyle=`hsla(${hue},60%,50%,0.8)`;
        ctx.beginPath();ctx.arc(bx,by,size,0,Math.PI*2);ctx.fill();
      }

      const predData=world.get_predator_data();
      for(let i=0;i<predData.length;i+=7){
        const px=predData[i],py=predData[i+1],pvx=predData[i+2],pvy=predData[i+3];
        const energy=predData[i+4],isLeader=predData[i+5]>0.5,gen=predData[i+6];
        const angle=Math.atan2(pvy,pvx);
        const size=12+gen*2;
        const ng=1-dayPhase;
        ctx.save();ctx.translate(px,py);ctx.rotate(angle);
        const grad=ctx.createRadialGradient(0,0,0,0,0,25+ng*15);
        grad.addColorStop(0,`rgba(255,50,50,${0.3+ng*0.3})`);
        grad.addColorStop(1,'rgba(255,50,50,0)');
        ctx.fillStyle=grad;ctx.beginPath();ctx.arc(0,0,25+ng*15,0,Math.PI*2);ctx.fill();
        if(isLeader){
          ctx.fillStyle='rgba(255,215,0,0.9)';ctx.beginPath();
          ctx.moveTo(-6,-size*0.8);ctx.lineTo(-3,-size*0.5);ctx.lineTo(0,-size*0.8);
          ctx.lineTo(3,-size*0.5);ctx.lineTo(6,-size*0.8);ctx.lineTo(4,-size*0.4);ctx.lineTo(-4,-size*0.4);ctx.fill();
        }
        ctx.fillStyle=`hsl(0,80%,${35+energy*0.15}%)`;ctx.beginPath();
        ctx.moveTo(size,0);ctx.lineTo(-size*0.5,-size*0.6);ctx.lineTo(-size*0.3,0);ctx.lineTo(-size*0.5,size*0.6);ctx.closePath();ctx.fill();
        ctx.restore();
      }

      const boidData=world.get_boid_data();
      for(let i=0;i<boidData.length;i+=11){
        const bx=boidData[i],by=boidData[i+1],bvx=boidData[i+2],bvy=boidData[i+3];
        const hue=boidData[i+4],energy=boidData[i+5],maxEnergy=boidData[i+6];
        const sizeMult=boidData[i+7],mutations=boidData[i+8],fear=boidData[i+9],state=boidData[i+10];
        const angle=Math.atan2(bvy,bvx);
        const baseSize=6*sizeMult;
        const isCollapsed=state===2;

        if(showTrailsRef.current&&!isCollapsed){
          ctx.strokeStyle=`hsla(${hue},70%,60%,0.3)`;ctx.lineWidth=1;
          ctx.beginPath();ctx.moveTo(bx,by);ctx.lineTo(bx-bvx*4,by-bvy*4);ctx.stroke();
        }
        if(fear>0.3){
          ctx.beginPath();ctx.arc(bx,by,baseSize*2,0,Math.PI*2);
          const glow=ctx.createRadialGradient(bx,by,0,bx,by,baseSize*2);
          glow.addColorStop(0,`rgba(255,100,100,${fear*0.4})`);glow.addColorStop(1,'rgba(255,100,100,0)');
          ctx.fillStyle=glow;ctx.fill();
        }
        if(mutations>0){
          ctx.beginPath();ctx.arc(bx,by,baseSize*1.5,0,Math.PI*2);
          const mutGlow=ctx.createRadialGradient(bx,by,0,bx,by,baseSize*1.5);
          mutGlow.addColorStop(0,`rgba(200,100,255,${0.2+mutations*0.05})`);mutGlow.addColorStop(1,'rgba(200,100,255,0)');
          ctx.fillStyle=mutGlow;ctx.fill();
        }
        ctx.save();ctx.translate(bx,by);ctx.rotate(angle);
        if(isCollapsed){
          ctx.fillStyle=`hsla(${hue},40%,40%,0.7)`;
          ctx.beginPath();ctx.ellipse(0,0,baseSize,baseSize*0.5,0,0,Math.PI*2);ctx.fill();
        }else{
          const lightness=45+dayPhase*15;
          ctx.fillStyle=`hsla(${hue},70%,${lightness}%,0.9)`;
          ctx.beginPath();ctx.moveTo(baseSize,0);ctx.lineTo(-baseSize*0.6,-baseSize*0.5);
          ctx.lineTo(-baseSize*0.3,0);ctx.lineTo(-baseSize*0.6,baseSize*0.5);ctx.closePath();ctx.fill();
          const energyRatio=energy/maxEnergy;
          if(energyRatio<0.3){
            ctx.fillStyle=`rgba(255,${energyRatio*255},0,0.6)`;
            ctx.beginPath();ctx.arc(0,0,2,0,Math.PI*2);ctx.fill();
          }
        }
        ctx.restore();
      }

      for(const r of eff.ripples)r.draw(ctx);
      if(cursorPosRef.current.active&&cursorModeRef.current!=='none'){
        ctx.strokeStyle=cursorModeRef.current==='attract'?'rgba(100,255,150,0.4)':'rgba(255,100,100,0.4)';
        ctx.lineWidth=2;ctx.beginPath();
        ctx.arc(cursorPosRef.current.x,cursorPosRef.current.y,100*settingsRef.current.cursorStrength,0,Math.PI*2);
        ctx.stroke();
      }
      if(pausedRef.current){
        ctx.fillStyle='rgba(0,0,0,0.3)';ctx.fillRect(0,0,w,h);
        ctx.fillStyle='white';ctx.font='48px sans-serif';ctx.textAlign='center';ctx.fillText('PAUSED',w/2,h/2);
      }
      animRef.current=requestAnimationFrame(animate);
    };

    ctx.fillStyle='rgb(12,12,22)';ctx.fillRect(0,0,canvas.width,canvas.height);
    animate();
    return()=>{if(animRef.current)cancelAnimationFrame(animRef.current)};
  },[initEffects,addRipple,addDangerZone]);

  const handleClick=e=>{
    const rect=canvasRef.current.getBoundingClientRect();
    const x=(e.clientX-rect.left)*(canvasRef.current.width/rect.width);
    const y=(e.clientY-rect.top)*(canvasRef.current.height/rect.height);
    const world=worldRef.current;
    switch(tool){
      case'obstacle':world.add_obstacle(x,y);break;
      case'predator':world.add_predator(x,y);addRipple(x,y,'rgb(255,50,50)',35);break;
      case'food':world.add_food(x,y);addRipple(x,y,'rgb(100,255,150)',25);break;
      case'boid':world.add_boids(x,y,8);addRipple(x,y,'rgb(150,200,255)',40);break;
      case'remove':world.remove_obstacle(x,y);break;
    }
  };

  const handleMouseMove=e=>{
    const rect=canvasRef.current.getBoundingClientRect();
    cursorPosRef.current.x=(e.clientX-rect.left)*(canvasRef.current.width/rect.width);
    cursorPosRef.current.y=(e.clientY-rect.top)*(canvasRef.current.height/rect.height);
    cursorPosRef.current.active=true;
  };

  const handleMouseLeave=()=>{cursorPosRef.current.active=false};

  const resizeCanvas=(newW,newH)=>{
    setCanvasSize({w:newW,h:newH});
    worldRef.current.reset(newW,newH,settingsRef.current.startBoids);
    initEffects(newW,newH);
  };

  const resetWorld=()=>{
    worldRef.current.reset(canvasSize.w,canvasSize.h,settingsRef.current.startBoids);
    initEffects(canvasSize.w,canvasSize.h);
  };

  const tools=[{id:'food',label:'+',title:'Add Food'},{id:'obstacle',label:'O',title:'Add Obstacle'},{id:'remove',label:'X',title:'Remove Obstacle'},{id:'predator',label:'P',title:'Add Predator'},{id:'boid',label:'B',title:'Add Boids'}];

  return(
    <div className="flex flex-col items-center gap-1 p-2 bg-gray-900 min-h-screen">
      <div className="flex items-center gap-3 flex-wrap justify-center">
        <span className="text-gray-400 text-sm">{stats.day?'Day':'Night'} | {stats.boids} boids | {stats.predators} pred | {stats.bugs} bugs | {stats.fps}fps</span>
      </div>

      <canvas ref={canvasRef} width={canvasSize.w} height={canvasSize.h} onClick={handleClick} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave} className="border border-gray-700 rounded cursor-crosshair"/>

      <div className="flex flex-wrap justify-center items-center gap-1">
        <button onClick={()=>setPaused(p=>!p)} className={`px-2 py-0.5 rounded text-xs font-bold ${paused?'bg-green-600':'bg-yellow-600'}`}>{paused?'Play':'Pause'}</button>
        {tools.map(t=><button key={t.id} onClick={()=>setTool(t.id)} className={`w-7 h-7 rounded text-sm ${tool===t.id?'bg-cyan-600':'bg-gray-700 hover:bg-gray-600'}`} title={t.title}>{t.label}</button>)}
        <span className="mx-1 text-gray-600">|</span>
        {['none','attract','repel'].map(m=><button key={m} onClick={()=>setCursorMode(m)} className={`px-2 py-0.5 rounded text-xs ${cursorMode===m?m==='attract'?'bg-green-600':m==='repel'?'bg-red-600':'bg-gray-600':'bg-gray-700'}`}>{m==='none'?'Off':m==='attract'?'Attract':'Repel'}</button>)}
        <span className="mx-1 text-gray-600">|</span>
        <button onClick={()=>setShowTrails(t=>!t)} className={`px-2 py-0.5 rounded text-xs ${showTrails?'bg-purple-600':'bg-gray-700'}`}>Trails</button>
        <button onClick={resetWorld} className="px-2 py-0.5 bg-gray-700 rounded text-xs">Reset</button>
      </div>

      <div className="w-full max-w-4xl mt-1 p-2 bg-gray-800 rounded border border-gray-700">
        <div className="flex flex-wrap gap-4 justify-center items-center text-xs">
          <label className="flex items-center gap-1"><span className="text-gray-400">Speed</span><input type="number" defaultValue={1} step={0.5} onBlur={e=>{settingsRef.current.gameSpeed=Math.max(0.5,Math.min(10,parseFloat(e.target.value)||1))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Start Boids</span><input type="number" defaultValue={60} onBlur={e=>{settingsRef.current.startBoids=Math.max(10,Math.min(500,parseInt(e.target.value)||60))}} className="w-14 px-1 py-0.5 bg-gray-700 border border-gray-600 rounded text-white text-center"/></label>
          <label className="flex items-center gap-1"><span className="text-gray-400">Vortex</span><input type="range" min="0.1" max="3" step="0.1" defaultValue="1" onChange={e=>{settingsRef.current.cursorStrength=parseFloat(e.target.value)}} className="w-16"/></label>
          <div className="flex items-center gap-1"><span className="text-gray-400">Size</span>
            <button onClick={()=>resizeCanvas(900,450)} className={`px-1 py-0.5 rounded ${canvasSize.w===900?'bg-cyan-600':'bg-gray-700'}`}>M</button>
            <button onClick={()=>resizeCanvas(1200,550)} className={`px-1 py-0.5 rounded ${canvasSize.w===1200?'bg-cyan-600':'bg-gray-700'}`}>L</button>
            <button onClick={()=>resizeCanvas(1400,650)} className={`px-1 py-0.5 rounded ${canvasSize.w===1400?'bg-cyan-600':'bg-gray-700'}`}>XL</button>
          </div>
        </div>
      </div>

      {/* Collapsible Roster */}
      <div className="w-full max-w-4xl mt-1">
        <button onClick={()=>setRosterOpen(o=>!o)} className="w-full flex items-center justify-between p-2 bg-gray-800 rounded-t border border-gray-700 text-sm">
          <span className="text-pink-400 font-bold">Mutant Roster ({rosterData.length})</span>
          <span className="text-gray-500">{rosterOpen?'â–¼':'â–¶'}</span>
        </button>
        {rosterOpen&&(
          <div className="bg-gray-800/50 rounded-b border-x border-b border-gray-700 max-h-48 overflow-y-auto">
            {rosterData.length===0?<div className="p-3 text-gray-600 text-sm text-center">No mutants yet</div>:
            <div className="p-2 space-y-1">
              {rosterData.map((boid,idx)=>{
                const speciesColor=boid.species==='H'?'text-green-400':boid.species==='C'?'text-cyan-400':'text-yellow-400';
                const lifeColor=boid.lifePercent>60?'text-green-400':boid.lifePercent>30?'text-yellow-400':'text-red-400';
                return(
                  <div key={idx} className="p-2 rounded bg-gray-900/70 border-l-2 border-purple-500">
                    <div className="flex items-center gap-2 text-xs mb-1">
                      <span className={`font-bold ${speciesColor}`}>{boid.species}</span>
                      <span className={lifeColor}>{boid.lifePercent}% life</span>
                      <span className="text-gray-500">{boid.mutations.length} mutations</span>
                    </div>
                    <div className="flex flex-wrap gap-1">
                      {boid.mutations.map(m=>(
                        <span key={m.key} className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-xs" style={{backgroundColor:m.bg,color:m.color}}>
                          <span style={{fontSize:'1rem'}}>{m.emoji}</span>
                          <span>{m.name}</span>
                        </span>
                      ))}
                    </div>
                  </div>
                );
              })}
            </div>}
          </div>
        )}
      </div>

      {/* Collapsible Mutation Legend */}
      <div className="w-full max-w-4xl mt-1">
        <button onClick={()=>setLegendOpen(o=>!o)} className="w-full flex items-center justify-between p-2 bg-gray-800 rounded-t border border-gray-700 text-sm">
          <span className="text-purple-400 font-bold">Mutation Legend</span>
          <span className="text-gray-500">{legendOpen?'â–¼':'â–¶'}</span>
        </button>
        {legendOpen&&(
          <div className="bg-gray-800/50 rounded-b border-x border-b border-gray-700 p-3">
            <div className="flex flex-wrap gap-2 justify-center">
              {mutationDefs.map(m=>(
                <div key={m.key} className="flex items-center gap-1 px-2 py-1 rounded" style={{backgroundColor:m.bg}} title={m.name}>
                  <span style={{fontSize:'1.7rem'}}>{m.emoji}</span>
                  <span className="text-xs" style={{color:m.color}}>{m.name}</span>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// Initialize Wasm and render
async function main(){
  await init();
  const world=new WasmWorld(900,450,60);
  ReactDOM.createRoot(document.getElementById('root')).render(<App wasmWorld={world}/>);
}
main().catch(console.error);
</script>
</body>
</html>
